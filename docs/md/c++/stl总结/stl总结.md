## ğŸ“¦ STL

### STL å®¹å™¨

| å®¹å™¨                                                         | åº•å±‚æ•°æ®ç»“æ„      | æ—¶é—´å¤æ‚åº¦                                                   | æœ‰æ— åº | å¯ä¸å¯é‡å¤ | å…¶ä»–                                                         |
| ------------------------------------------------------------ | ----------------- | ------------------------------------------------------------ | ------ | ---------- | ------------------------------------------------------------ |
| [array](https://github.com/huihut/interview/tree/master/STL#array) | æ•°ç»„              | éšæœºè¯»æ”¹ O(1)                                                | æ— åº   | å¯é‡å¤     | æ”¯æŒéšæœºè®¿é—®                                                 |
| [vector](https://github.com/huihut/interview/tree/master/STL#vector) | æ•°ç»„              | éšæœºè¯»æ”¹ã€å°¾éƒ¨æ’å…¥ã€å°¾éƒ¨åˆ é™¤ O(1)<br/>å¤´éƒ¨æ’å…¥ã€å¤´éƒ¨åˆ é™¤ O(n) | æ— åº   | å¯é‡å¤     | æ”¯æŒéšæœºè®¿é—®                                                 |
| [deque](https://github.com/huihut/interview/tree/master/STL#deque) | åŒç«¯é˜Ÿåˆ—          | å¤´å°¾æ’å…¥ã€å¤´å°¾åˆ é™¤ O(1)                                      | æ— åº   | å¯é‡å¤     | ä¸€ä¸ªä¸­å¤®æ§åˆ¶å™¨ + å¤šä¸ªç¼“å†²åŒºï¼Œæ”¯æŒé¦–å°¾å¿«é€Ÿå¢åˆ ï¼Œæ”¯æŒéšæœºè®¿é—®  |
| [forward_list](https://github.com/huihut/interview/tree/master/STL#forward_list) | å•å‘é“¾è¡¨          | æ’å…¥ã€åˆ é™¤ O(1)                                              | æ— åº   | å¯é‡å¤     | ä¸æ”¯æŒéšæœºè®¿é—®                                               |
| [list](https://github.com/huihut/interview/tree/master/STL#list) | åŒå‘é“¾è¡¨          | æ’å…¥ã€åˆ é™¤ O(1)                                              | æ— åº   | å¯é‡å¤     | ä¸æ”¯æŒéšæœºè®¿é—®                                               |
| [stack](https://github.com/huihut/interview/tree/master/STL#stack) | deque / list      | é¡¶éƒ¨æ’å…¥ã€é¡¶éƒ¨åˆ é™¤ O(1)                                      | æ— åº   | å¯é‡å¤     | deque æˆ– list å°é—­å¤´ç«¯å¼€å£ï¼Œä¸ç”¨ vector çš„åŸå› åº”è¯¥æ˜¯å®¹é‡å¤§å°æœ‰é™åˆ¶ï¼Œæ‰©å®¹è€—æ—¶ |
| [queue](https://github.com/huihut/interview/tree/master/STL#queue) | deque / list      | å°¾éƒ¨æ’å…¥ã€å¤´éƒ¨åˆ é™¤ O(1)                                      | æ— åº   | å¯é‡å¤     | deque æˆ– list å°é—­å¤´ç«¯å¼€å£ï¼Œä¸ç”¨ vector çš„åŸå› åº”è¯¥æ˜¯å®¹é‡å¤§å°æœ‰é™åˆ¶ï¼Œæ‰©å®¹è€—æ—¶ |
| [priority_queue](https://github.com/huihut/interview/tree/master/STL#priority_queue) | vector + max-heap | æ’å…¥ã€åˆ é™¤ O(log<sub>2</sub>n)                               | æœ‰åº   | å¯é‡å¤     | vectorå®¹å™¨+heapå¤„ç†è§„åˆ™                                      |
| [set](https://github.com/huihut/interview/tree/master/STL#set) | çº¢é»‘æ ‘            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)                         | æœ‰åº   | ä¸å¯é‡å¤   |                                                              |
| [multiset](https://github.com/huihut/interview/tree/master/STL#multiset) | çº¢é»‘æ ‘            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)                         | æœ‰åº   | å¯é‡å¤     |                                                              |
| [map](https://github.com/huihut/interview/tree/master/STL#map) | çº¢é»‘æ ‘            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)                         | æœ‰åº   | ä¸å¯é‡å¤   |                                                              |
| [multimap](https://github.com/huihut/interview/tree/master/STL#multimap) | çº¢é»‘æ ‘            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)                         | æœ‰åº   | å¯é‡å¤     |                                                              |
| [unordered_set](https://github.com/huihut/interview/tree/master/STL#unordered_set) | å“ˆå¸Œè¡¨            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)                              | æ— åº   | ä¸å¯é‡å¤   |                                                              |
| [unordered_multiset](https://github.com/huihut/interview/tree/master/STL#unordered_multiset) | å“ˆå¸Œè¡¨            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)                              | æ— åº   | å¯é‡å¤     |                                                              |
| [unordered_map](https://github.com/huihut/interview/tree/master/STL#unordered_map) | å“ˆå¸Œè¡¨            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)                              | æ— åº   | ä¸å¯é‡å¤   |                                                              |
| [unordered_multimap](https://github.com/huihut/interview/tree/master/STL#unordered_multimap) | å“ˆå¸Œè¡¨            | æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)                              | æ— åº   | å¯é‡å¤     |                                                              |

### STL ç®—æ³•

| ç®—æ³•                                                         | åº•å±‚ç®—æ³•                                            | æ—¶é—´å¤æ‚åº¦            | å¯ä¸å¯é‡å¤ |
| ------------------------------------------------------------ | --------------------------------------------------- | --------------------- | ---------- |
| [find](http://www.cplusplus.com/reference/algorithm/find/)   | é¡ºåºæŸ¥æ‰¾                                            | O(n)                  | å¯é‡å¤     |
| [sort](https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808) | [å†…çœæ’åº](https://en.wikipedia.org/wiki/Introsort) | O(n*log<sub>2</sub>n) | å¯é‡å¤     |

[STL è¯¦ç»†æ–‡æ¡£](https://github.com/huihut/interview/blob/master/STL/STL.md)

# å®¹å™¨ï¼ˆcontainersï¼‰

## array

array æ˜¯å›ºå®šå¤§å°çš„é¡ºåºå®¹å™¨ï¼Œå®ƒä»¬ä¿å­˜äº†ä¸€ä¸ªä»¥ä¸¥æ ¼çš„çº¿æ€§é¡ºåºæ’åˆ—çš„ç‰¹å®šæ•°é‡çš„å…ƒç´ ã€‚

| æ–¹æ³•                         | å«ä¹‰                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| begin                        | è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨                         |
| end                          | è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åçš„ç†è®ºå…ƒç´ çš„è¿­ä»£å™¨         |
| rbegin                       | è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„åå‘è¿­ä»£å™¨                   |
| rend                         | è¿”å›ä¸€ä¸ªåå‘è¿­ä»£å™¨ï¼ŒæŒ‡å‘æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ç†è®ºå…ƒç´        |
| cbegin                       | è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¸¸é‡è¿­ä»£å™¨ï¼ˆconst_iteratorï¼‰   |
| cend                         | è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åçš„ç†è®ºå…ƒç´ çš„å¸¸é‡è¿­ä»£å™¨ï¼ˆconst_iteratorï¼‰ |
| crbegin                      | è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¸¸é‡åå‘è¿­ä»£å™¨ï¼ˆconst_reverse_iteratorï¼‰ |
| crend                        | è¿”å›æŒ‡å‘æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ç†è®ºå…ƒç´ çš„å¸¸é‡åå‘è¿­ä»£å™¨ï¼ˆconst_reverse_iteratorï¼‰ |
| size                         | è¿”å›æ•°ç»„å®¹å™¨ä¸­å…ƒç´ çš„æ•°é‡                                     |
| max_size                     | è¿”å›æ•°ç»„å®¹å™¨å¯å®¹çº³çš„æœ€å¤§å…ƒç´ æ•°                               |
| empty                        | è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼ŒæŒ‡ç¤ºæ•°ç»„å®¹å™¨æ˜¯å¦ä¸ºç©º                         |
| operator[]                   | è¿”å›å®¹å™¨ä¸­ç¬¬ nï¼ˆå‚æ•°ï¼‰ä¸ªä½ç½®çš„å…ƒç´ çš„å¼•ç”¨                     |
| at                           | è¿”å›å®¹å™¨ä¸­ç¬¬ nï¼ˆå‚æ•°ï¼‰ä¸ªä½ç½®çš„å…ƒç´ çš„å¼•ç”¨                     |
| front                        | è¿”å›å¯¹å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨                                 |
| back                         | è¿”å›å¯¹å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨                               |
| data                         | è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆ                               |
| fill                         | ç”¨ valï¼ˆå‚æ•°ï¼‰å¡«å……æ•°ç»„æ‰€æœ‰å…ƒç´                                |
| swap                         | é€šè¿‡ xï¼ˆå‚æ•°ï¼‰çš„å†…å®¹äº¤æ¢æ•°ç»„çš„å†…å®¹                           |
| getï¼ˆarrayï¼‰                 | å½¢å¦‚ `std::get<0>(myarray)`ï¼›ä¼ å…¥ä¸€ä¸ªæ•°ç»„å®¹å™¨ï¼Œè¿”å›æŒ‡å®šä½ç½®å…ƒç´ çš„å¼•ç”¨ |
| relational operators (array) | å½¢å¦‚ `arrayA > arrayB`ï¼›ä¾æ­¤æ¯”è¾ƒæ•°ç»„æ¯ä¸ªå…ƒç´ çš„å¤§å°å…³ç³»       |

## vector

vector æ˜¯è¡¨ç¤ºå¯ä»¥æ”¹å˜å¤§å°çš„æ•°ç»„çš„åºåˆ—å®¹å™¨ã€‚

| æ–¹æ³•                          | å«ä¹‰                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| vector                        | æ„é€ å‡½æ•°                                                     |
| ~vector                       | ææ„å‡½æ•°ï¼Œé”€æ¯å®¹å™¨å¯¹è±¡                                       |
| operator=                     | å°†æ–°å†…å®¹åˆ†é…ç»™å®¹å™¨ï¼Œæ›¿æ¢å…¶å½“å‰å†…å®¹ï¼Œå¹¶ç›¸åº”åœ°ä¿®æ”¹å…¶å¤§å°       |
| begin                         | è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨                             |
| end                           | è¿”å›æŒ‡å‘å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åçš„ç†è®ºå…ƒç´ çš„è¿­ä»£å™¨             |
| rbegin                        | è¿”å›æŒ‡å‘å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„åå‘è¿­ä»£å™¨                       |
| rend                          | è¿”å›ä¸€ä¸ªåå‘è¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ç†è®ºå…ƒç´            |
| cbegin                        | è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¸¸é‡è¿­ä»£å™¨ï¼ˆconst_iteratorï¼‰       |
| cend                          | è¿”å›æŒ‡å‘å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åçš„ç†è®ºå…ƒç´ çš„å¸¸é‡è¿­ä»£å™¨ï¼ˆconst_iteratorï¼‰ |
| crbegin                       | è¿”å›æŒ‡å‘å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¸¸é‡åå‘è¿­ä»£å™¨ï¼ˆconst_reverse_iteratorï¼‰ |
| crend                         | è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ç†è®ºå…ƒç´ çš„å¸¸é‡åå‘è¿­ä»£å™¨ï¼ˆconst_reverse_iteratorï¼‰ |
| size                          | è¿”å›å®¹å™¨ä¸­å…ƒç´ çš„æ•°é‡                                         |
| max_size                      | è¿”å›å®¹å™¨å¯å®¹çº³çš„æœ€å¤§å…ƒç´ æ•°                                   |
| resize                        | è°ƒæ•´å®¹å™¨çš„å¤§å°ï¼Œä½¿å…¶åŒ…å« nï¼ˆå‚æ•°ï¼‰ä¸ªå…ƒç´                      |
| capacity                      | è¿”å›å½“å‰ä¸º vector åˆ†é…çš„å­˜å‚¨ç©ºé—´ï¼ˆå®¹é‡ï¼‰çš„å¤§å°               |
| empty                         | è¿”å› vector æ˜¯å¦ä¸ºç©º                                         |
| reserve                       | è¯·æ±‚ vector å®¹é‡è‡³å°‘è¶³ä»¥åŒ…å« nï¼ˆå‚æ•°ï¼‰ä¸ªå…ƒç´                  |
| shrink_to_fit                 | è¦æ±‚å®¹å™¨å‡å°å…¶ capacityï¼ˆå®¹é‡ï¼‰ä»¥é€‚åº”å…¶ sizeï¼ˆå…ƒç´ æ•°é‡ï¼‰     |
| operator[]                    | è¿”å›å®¹å™¨ä¸­ç¬¬ nï¼ˆå‚æ•°ï¼‰ä¸ªä½ç½®çš„å…ƒç´ çš„å¼•ç”¨                     |
| at                            | è¿”å›å®¹å™¨ä¸­ç¬¬ nï¼ˆå‚æ•°ï¼‰ä¸ªä½ç½®çš„å…ƒç´ çš„å¼•ç”¨                     |
| front                         | è¿”å›å¯¹å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨                                 |
| back                          | è¿”å›å¯¹å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨                               |
| data                          | è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆ                               |
| assign                        | å°†æ–°å†…å®¹åˆ†é…ç»™ vectorï¼Œæ›¿æ¢å…¶å½“å‰å†…å®¹ï¼Œå¹¶ç›¸åº”åœ°ä¿®æ”¹å…¶ size   |
| push_back                     | åœ¨å®¹å™¨çš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åæ·»åŠ ä¸€ä¸ªæ–°å…ƒç´                        |
| pop_back                      | åˆ é™¤å®¹å™¨ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæœ‰æ•ˆåœ°å°†å®¹å™¨ size å‡å°‘ä¸€ä¸ª         |
| insert                        | é€šè¿‡åœ¨æŒ‡å®šä½ç½®çš„å…ƒç´ ä¹‹å‰æ’å…¥æ–°å…ƒç´ æ¥æ‰©å±•è¯¥å®¹å™¨ï¼Œé€šè¿‡æ’å…¥å…ƒç´ çš„æ•°é‡æœ‰æ•ˆåœ°å¢åŠ å®¹å™¨å¤§å° |
| erase                         | ä» vector ä¸­åˆ é™¤å•ä¸ªå…ƒç´ ï¼ˆ`position`ï¼‰æˆ–ä¸€ç³»åˆ—å…ƒç´ ï¼ˆ`[firstï¼Œlast)`ï¼‰ï¼Œè¿™æœ‰æ•ˆåœ°å‡å°‘äº†è¢«å»é™¤çš„å…ƒç´ çš„æ•°é‡ï¼Œä»è€Œç ´åäº†å®¹å™¨çš„å¤§å° |
| swap                          | é€šè¿‡ xï¼ˆå‚æ•°ï¼‰çš„å†…å®¹äº¤æ¢å®¹å™¨çš„å†…å®¹ï¼Œx æ˜¯å¦ä¸€ä¸ªç±»å‹ç›¸åŒã€size å¯èƒ½ä¸åŒçš„ vector å¯¹è±¡ |
| clear                         | ä» vector ä¸­åˆ é™¤æ‰€æœ‰çš„å…ƒç´ ï¼ˆè¢«é”€æ¯ï¼‰ï¼Œç•™ä¸‹ size ä¸º 0 çš„å®¹å™¨  |
| emplace                       | é€šè¿‡åœ¨ positionï¼ˆå‚æ•°ï¼‰ä½ç½®å¤„æ’å…¥æ–°å…ƒç´  argsï¼ˆå‚æ•°ï¼‰æ¥æ‰©å±•å®¹å™¨ |
| emplace_back                  | åœ¨ vector çš„æœ«å°¾æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œç´§è·Ÿåœ¨å½“å‰çš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å |
| get_allocator                 | è¿”å›ä¸vectorå…³è”çš„æ„é€ å™¨å¯¹è±¡çš„å‰¯æœ¬                           |
| swap(vector)                  | å®¹å™¨ xï¼ˆå‚æ•°ï¼‰çš„å†…å®¹ä¸å®¹å™¨ yï¼ˆå‚æ•°ï¼‰çš„å†…å®¹äº¤æ¢ã€‚ä¸¤ä¸ªå®¹å™¨å¯¹è±¡éƒ½å¿…é¡»æ˜¯ç›¸åŒçš„ç±»å‹ï¼ˆç›¸åŒçš„æ¨¡æ¿å‚æ•°ï¼‰ï¼Œå°½ç®¡å¤§å°å¯èƒ½ä¸åŒ |
| relational operators (vector) | å½¢å¦‚ `vectorA > vectorB`ï¼›ä¾æ­¤æ¯”è¾ƒæ¯ä¸ªå…ƒç´ çš„å¤§å°å…³ç³»         |

## deque

dequeï¼ˆ['dek]ï¼‰ï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ˜¯double-ended queue çš„ä¸€ä¸ªä¸è§„åˆ™ç¼©å†™ã€‚dequeæ˜¯å…·æœ‰åŠ¨æ€å¤§å°çš„åºåˆ—å®¹å™¨ï¼Œå¯ä»¥åœ¨ä¸¤ç«¯ï¼ˆå‰ç«¯æˆ–åç«¯ï¼‰æ‰©å±•æˆ–æ”¶ç¼©ã€‚

| æ–¹æ³•          | å«ä¹‰                                                         |
| ------------- | ------------------------------------------------------------ |
| deque         | æ„é€ å‡½æ•°                                                     |
| push_back     | åœ¨å½“å‰çš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å ï¼Œåœ¨ deque å®¹å™¨çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªæ–°å…ƒç´  |
| push_front    | åœ¨ deque å®¹å™¨çš„å¼€å§‹ä½ç½®æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œä½äºå½“å‰çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ |
| pop_back      | åˆ é™¤ deque å®¹å™¨ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæœ‰æ•ˆåœ°å°†å®¹å™¨å¤§å°å‡å°‘ä¸€ä¸ª    |
| pop_front     | åˆ é™¤ deque å®¹å™¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæœ‰æ•ˆåœ°å‡å°å…¶å¤§å°              |
| emplace_front | åœ¨ deque çš„å¼€å¤´æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œå°±åœ¨å…¶å½“å‰çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰  |
| emplace_back  | åœ¨ deque çš„æœ«å°¾æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œç´§è·Ÿåœ¨å½“å‰çš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å |

## forward\_list

forward_listï¼ˆå•å‘é“¾è¡¨ï¼‰æ˜¯åºåˆ—å®¹å™¨ï¼Œå…è®¸åœ¨åºåˆ—ä¸­çš„ä»»ä½•åœ°æ–¹è¿›è¡Œæ’å®šçš„æ—¶é—´æ’å…¥å’Œæ“¦é™¤æ“ä½œã€‚

| æ–¹æ³•           | å«ä¹‰                                                |
| -------------- | --------------------------------------------------- |
| forward\_list  | è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ä½ç½®çš„è¿­ä»£å™¨          |
| cbefore\_begin | è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ä½ç½®çš„ const_iterator |

## list

listï¼ŒåŒå‘é“¾è¡¨ï¼Œæ˜¯åºåˆ—å®¹å™¨ï¼Œå…è®¸åœ¨åºåˆ—ä¸­çš„ä»»ä½•åœ°æ–¹è¿›è¡Œå¸¸æ•°æ—¶é—´æ’å…¥å’Œæ“¦é™¤æ“ä½œï¼Œå¹¶åœ¨ä¸¤ä¸ªæ–¹å‘ä¸Šè¿›è¡Œè¿­ä»£ã€‚

## stack

stack æ˜¯ä¸€ç§å®¹å™¨é€‚é…å™¨ï¼Œç”¨äºåœ¨LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰çš„æ“ä½œï¼Œå…¶ä¸­å…ƒç´ ä»…ä»å®¹å™¨çš„ä¸€ç«¯æ’å…¥å’Œæå–ã€‚

## queue

queue æ˜¯ä¸€ç§å®¹å™¨é€‚é…å™¨ï¼Œç”¨äºåœ¨FIFOï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰çš„æ“ä½œï¼Œå…¶ä¸­å…ƒç´ æ’å…¥åˆ°å®¹å™¨çš„ä¸€ç«¯å¹¶ä»å¦ä¸€ç«¯æå–ã€‚

## priority_queue

## set

set æ˜¯æŒ‰ç…§ç‰¹å®šé¡ºåºå­˜å‚¨å”¯ä¸€å…ƒç´ çš„å®¹å™¨ã€‚

## multiset

## map

map æ˜¯å…³è”å®¹å™¨ï¼ŒæŒ‰ç…§ç‰¹å®šé¡ºåºå­˜å‚¨ç”± key value (é”®å€¼) å’Œ mapped value (æ˜ å°„å€¼) ç»„åˆå½¢æˆçš„å…ƒç´ ã€‚

| æ–¹æ³•        | å«ä¹‰                                                         |
| ----------- | ------------------------------------------------------------ |
| map         | æ„é€ å‡½æ•°                                                     |
| begin       | è¿”å›å¼•ç”¨å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨                             |
| key_comp    | è¿”å›å®¹å™¨ç”¨äºæ¯”è¾ƒé”®çš„æ¯”è¾ƒå¯¹è±¡çš„å‰¯æœ¬                           |
| value_comp  | è¿”å›å¯ç”¨äºæ¯”è¾ƒä¸¤ä¸ªå…ƒç´ çš„æ¯”è¾ƒå¯¹è±¡ï¼Œä»¥è·å–ç¬¬ä¸€ä¸ªå…ƒç´ çš„é”®æ˜¯å¦åœ¨ç¬¬äºŒä¸ªå…ƒç´ ä¹‹å‰ |
| find        | åœ¨å®¹å™¨ä¸­æœç´¢å…·æœ‰ç­‰äº kï¼ˆå‚æ•°ï¼‰çš„é”®çš„å…ƒç´ ï¼Œå¦‚æœæ‰¾åˆ°åˆ™è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å› map::end çš„è¿­ä»£å™¨ |
| count       | åœ¨å®¹å™¨ä¸­æœç´¢å…·æœ‰ç­‰äº kï¼ˆå‚æ•°ï¼‰çš„é”®çš„å…ƒç´ ï¼Œå¹¶è¿”å›åŒ¹é…çš„æ•°é‡   |
| lower_bound | è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— `[first, last)`ï¼ˆå‚æ•°ï¼‰ä¸­çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºå€¼ valï¼ˆå‚æ•°ï¼‰çš„ä½ç½®çš„è¿­ä»£å™¨ |
| upper_bound | è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— `[first, last)`ï¼ˆå‚æ•°ï¼‰ä¸­ç¬¬ä¸€ä¸ªå¤§äº valï¼ˆå‚æ•°ï¼‰çš„ä½ç½®çš„è¿­ä»£å™¨ |
| equal_range | è·å–ç›¸åŒå…ƒç´ çš„èŒƒå›´ï¼Œè¿”å›åŒ…å«å®¹å™¨ä¸­æ‰€æœ‰å…·æœ‰ä¸ kï¼ˆå‚æ•°ï¼‰ç­‰ä»·çš„é”®çš„å…ƒç´ çš„èŒƒå›´è¾¹ç•Œï¼ˆ`pair< map<char,int>::iterator, map<char,int>::iterator >`ï¼‰ |

## multimap

## unordered\_set

## unordered\_multiset

## unordered\_map

## unordered\_multimap

## tuple

å…ƒç»„æ˜¯ä¸€ä¸ªèƒ½å¤Ÿå®¹çº³å…ƒç´ é›†åˆçš„å¯¹è±¡ã€‚æ¯ä¸ªå…ƒç´ å¯ä»¥æ˜¯ä¸åŒçš„ç±»å‹ã€‚

## pair

è¿™ä¸ªç±»æŠŠä¸€å¯¹å€¼ï¼ˆvaluesï¼‰ç»“åˆåœ¨ä¸€èµ·ï¼Œè¿™äº›å€¼å¯èƒ½æ˜¯ä¸åŒçš„ç±»å‹ï¼ˆT1 å’Œ T2ï¼‰ã€‚æ¯ä¸ªå€¼å¯ä»¥è¢«å…¬æœ‰çš„æˆå‘˜å˜é‡firstã€secondè®¿é—®ã€‚

# ç®—æ³•ï¼ˆalgorithmsï¼‰

```cpp
// ç®€å•æŸ¥æ‰¾ç®—æ³•ï¼Œè¦æ±‚è¾“å…¥è¿­ä»£å™¨ï¼ˆinput iteratorï¼‰
find(beg, end, val); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘è¾“å…¥åºåˆ—ä¸­ç¬¬ä¸€ä¸ªç­‰äº val çš„å…ƒç´ ï¼Œæœªæ‰¾åˆ°è¿”å› end
find_if(beg, end, unaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬ä¸€ä¸ªæ»¡è¶³ unaryPred çš„å…ƒç´ ï¼Œæœªæ‰¾åˆ°è¿”å› end
find_if_not(beg, end, unaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬ä¸€ä¸ªä»¤ unaryPred ä¸º false çš„å…ƒç´ ï¼Œæœªæ‰¾åˆ°è¿”å› end
count(beg, end, val); // è¿”å›ä¸€ä¸ªè®¡æ•°å™¨ï¼ŒæŒ‡å‡º val å‡ºç°äº†å¤šå°‘æ¬¡
count_if(beg, end, unaryPred); // ç»Ÿè®¡æœ‰å¤šå°‘ä¸ªå…ƒç´ æ»¡è¶³ unaryPred
all_of(beg, end, unaryPred); // è¿”å›ä¸€ä¸ª bool å€¼ï¼Œåˆ¤æ–­æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³ unaryPred
any_of(beg, end, unaryPred); // è¿”å›ä¸€ä¸ª bool å€¼ï¼Œåˆ¤æ–­æ˜¯å¦ä»»æ„ï¼ˆå­˜åœ¨ï¼‰ä¸€ä¸ªå…ƒç´ æ»¡è¶³ unaryPred
none_of(beg, end, unaryPred); // è¿”å›ä¸€ä¸ª bool å€¼ï¼Œåˆ¤æ–­æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½ä¸æ»¡è¶³ unaryPred

// æŸ¥æ‰¾é‡å¤å€¼çš„ç®—æ³•ï¼Œä¼ å…¥å‘å‰è¿­ä»£å™¨ï¼ˆforward iteratorï¼‰
adjacent_find(beg, end); // è¿”å›æŒ‡å‘ç¬¬ä¸€å¯¹ç›¸é‚»é‡å¤å…ƒç´ çš„è¿­ä»£å™¨ï¼Œæ— ç›¸é‚»å…ƒç´ åˆ™è¿”å› end
adjacent_find(beg, end, binaryPred); // è¿”å›æŒ‡å‘ç¬¬ä¸€å¯¹ç›¸é‚»é‡å¤å…ƒç´ çš„è¿­ä»£å™¨ï¼Œæ— ç›¸é‚»å…ƒç´ åˆ™è¿”å› end
search_n(beg, end, count, val); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä»æ­¤ä½ç½®å¼€å§‹æœ‰ count ä¸ªç›¸ç­‰å…ƒç´ ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
search_n(beg, end, count, val, binaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä»æ­¤ä½ç½®å¼€å§‹æœ‰ count ä¸ªç›¸ç­‰å…ƒç´ ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end

// æŸ¥æ‰¾å­åºåˆ—ç®—æ³•ï¼Œé™¤ find_first_ofï¼ˆå‰ä¸¤ä¸ªè¾“å…¥è¿­ä»£å™¨ï¼Œåä¸¤ä¸ªå‰å‘è¿­ä»£å™¨ï¼‰ å¤–ï¼Œéƒ½è¦æ±‚ä¸¤ä¸ªå‰å‘è¿­ä»£å™¨
search(beg1, end1, beg2, end2); // è¿”å›ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ï¼ˆå­åºåˆ—ï¼‰åœ¨çˆ¹ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å› end1
search(beg1, end1, beg2, end2, binaryPred); // è¿”å›ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ï¼ˆå­åºåˆ—ï¼‰åœ¨çˆ¹ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å› end1
find_first_of(beg1, end1, beg2, end2); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸­ä»»æ„å…ƒç´ åœ¨ç¬¬ä¸€ä¸ªèŒƒå›´ä¸­é¦–æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å›end1
find_first_of(beg1, end1, beg2, end2, binaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸­ä»»æ„å…ƒç´ åœ¨ç¬¬ä¸€ä¸ªèŒƒå›´ä¸­é¦–æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å›end1
find_end(beg1, end1, beg2, end2); // ç±»ä¼¼ searchï¼Œä½†è¿”å›çš„æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚å¦‚æœç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­æœªæ‰¾åˆ°å®ƒï¼Œåˆ™è¿”å› end1
find_end(beg1, end1, beg2, end2, binaryPred); // ç±»ä¼¼ searchï¼Œä½†è¿”å›çš„æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚å¦‚æœç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­æœªæ‰¾åˆ°å®ƒï¼Œåˆ™è¿”å› end1

// å…¶ä»–åªè¯»ç®—æ³•ï¼Œä¼ å…¥è¾“å…¥è¿­ä»£å™¨
for_each(beg, end, unaryOp); // å¯¹è¾“å…¥åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ åº”ç”¨å¯è°ƒç”¨å¯¹è±¡ unaryOpï¼ŒunaryOp çš„è¿”å›å€¼è¢«å¿½ç•¥
mismatch(beg1, end1, beg2); // æ¯”è¾ƒä¸¤ä¸ªåºåˆ—ä¸­çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨çš„ pairï¼Œè¡¨ç¤ºä¸¤ä¸ªåºåˆ—ä¸­ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„å…ƒç´ 
mismatch(beg1, end1, beg2, binaryPred); // æ¯”è¾ƒä¸¤ä¸ªåºåˆ—ä¸­çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨çš„ pairï¼Œè¡¨ç¤ºä¸¤ä¸ªåºåˆ—ä¸­ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„å…ƒç´ 
equal(beg1, end1, beg2); // æ¯”è¾ƒæ¯ä¸ªå…ƒç´ ï¼Œç¡®å®šä¸¤ä¸ªåºåˆ—æ˜¯å¦ç›¸ç­‰ã€‚
equal(beg1, end1, beg2, binaryPred); // æ¯”è¾ƒæ¯ä¸ªå…ƒç´ ï¼Œç¡®å®šä¸¤ä¸ªåºåˆ—æ˜¯å¦ç›¸ç­‰ã€‚

// äºŒåˆ†æœç´¢ç®—æ³•ï¼Œä¼ å…¥å‰å‘è¿­ä»£å™¨æˆ–éšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆrandom-access iteratorï¼‰ï¼Œè¦æ±‚åºåˆ—ä¸­çš„å…ƒç´ å·²ç»æ˜¯æœ‰åºçš„ã€‚é€šè¿‡å°äºè¿ç®—ç¬¦ï¼ˆ<ï¼‰æˆ– comp æ¯”è¾ƒæ“ä½œå®ç°æ¯”è¾ƒã€‚
lower_bound(beg, end, val); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºå€¼ val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
lower_bound(beg, end, val, comp); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºå€¼ val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
upper_bound(beg, end, val); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­ç¬¬ä¸€ä¸ªå¤§äº val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
upper_bound(beg, end, val, comp); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­ç¬¬ä¸€ä¸ªå¤§äº val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
equal_range(beg, end, val); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ first æˆå‘˜æ˜¯ lower_bound è¿”å›çš„è¿­ä»£å™¨ï¼Œå…¶ second æˆå‘˜æ˜¯ upper_bound è¿”å›çš„è¿­ä»£å™¨
binary_search(beg, end, val); // è¿”å›ä¸€ä¸ª bool å€¼ï¼ŒæŒ‡å‡ºåºåˆ—ä¸­æ˜¯å¦åŒ…å«ç­‰äº val çš„å…ƒç´ ã€‚å¯¹äºä¸¤ä¸ªå€¼ x å’Œ yï¼Œå½“ x ä¸å°äº y ä¸” y ä¹Ÿä¸å°äº x æ—¶ï¼Œè®¤ä¸ºå®ƒä»¬ç›¸ç­‰ã€‚

// åªå†™ä¸è¯»ç®—æ³•ï¼Œè¦æ±‚è¾“å‡ºè¿­ä»£å™¨ï¼ˆoutput iteratorï¼‰
fill(beg, end, val); // å°† val èµ‹äºˆæ¯ä¸ªå…ƒç´ ï¼Œè¿”å› void
fill_n(beg, cnt, val); // å°† val èµ‹äºˆ cnt ä¸ªå…ƒç´ ï¼Œè¿”å›æŒ‡å‘å†™å…¥åˆ°è¾“å‡ºåºåˆ—æœ€æœ‰ä¸€ä¸ªå…ƒç´ ä¹‹åä½ç½®çš„è¿­ä»£å™¨
genetate(beg, end, Gen); // æ¯æ¬¡è°ƒç”¨ Gen() ç”Ÿæˆä¸åŒçš„å€¼èµ‹äºˆæ¯ä¸ªåºåˆ—ï¼Œè¿”å› void
genetate_n(beg, cnt, Gen); // æ¯æ¬¡è°ƒç”¨ Gen() ç”Ÿæˆä¸åŒçš„å€¼èµ‹äºˆ cnt ä¸ªåºåˆ—ï¼Œè¿”å›æŒ‡å‘å†™å…¥åˆ°è¾“å‡ºåºåˆ—æœ€æœ‰ä¸€ä¸ªå…ƒç´ ä¹‹åä½ç½®çš„è¿­ä»£å™¨

// ä½¿ç”¨è¾“å…¥è¿­ä»£å™¨çš„å†™ç®—æ³•ï¼Œè¯»å–ä¸€ä¸ªè¾“å…¥åºåˆ—ï¼Œå°†å€¼å†™å…¥åˆ°ä¸€ä¸ªè¾“å‡ºåºåˆ—ï¼ˆdestï¼‰ä¸­
copy(beg, end, dest); // ä»è¾“å…¥èŒƒå›´å°†å…ƒç´ æ‹·è´æ‰€æœ‰å…ƒç´ åˆ° dest æŒ‡å®šå®šçš„ç›®çš„åºåˆ—
copy_if(beg, end, dest, unaryPred); // ä»è¾“å…¥èŒƒå›´å°†å…ƒç´ æ‹·è´æ»¡è¶³ unaryPred çš„å…ƒç´ åˆ° dest æŒ‡å®šå®šçš„ç›®çš„åºåˆ—
copy_n(beg, n, dest); // ä»è¾“å…¥èŒƒå›´å°†å…ƒç´ æ‹·è´å‰ n ä¸ªå…ƒç´ åˆ° dest æŒ‡å®šå®šçš„ç›®çš„åºåˆ—
move(beg, end, dest); // å¯¹è¾“å…¥åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨ std::moveï¼Œå°†å…¶ç§»åŠ¨åˆ°è¿­ä»£å™¨ dest å¼€å§‹å§‹çš„åºåˆ—ä¸­
transform(beg, end, dest, unaryOp); // è°ƒç”¨ç»™å®šæ“ä½œï¼ˆä¸€å…ƒæ“ä½œï¼‰ï¼Œå¹¶å°†ç»“æœå†™åˆ°destä¸­
transform(beg, end, beg2, dest, binaryOp); // è°ƒç”¨ç»™å®šæ“ä½œï¼ˆäºŒå…ƒæ“ä½œï¼‰ï¼Œå¹¶å°†ç»“æœå†™åˆ°destä¸­
replace_copy(beg, end, dest, old_val, new_val); // å°†æ¯ä¸ªå…ƒç´ æ‹·è´åˆ° destï¼Œå°†ç­‰äº old_val çš„çš„å…ƒç´ æ›¿æ¢ä¸º new_val
replace_copy_if(beg, end, dest, unaryPred, new_val); // å°†æ¯ä¸ªå…ƒç´ æ‹·è´åˆ° destï¼Œå°†æ»¡è¶³ unaryPred çš„çš„å…ƒç´ æ›¿æ¢ä¸º new_val
merge(beg1, end1, beg2, end2, dest); // ä¸¤ä¸ªè¾“å…¥åºåˆ—å¿…é¡»éƒ½æ˜¯æœ‰åºçš„ï¼Œç”¨ < è¿ç®—ç¬¦å°†åˆå¹¶åçš„åºåˆ—å†™å…¥åˆ° dest ä¸­
merge(beg1, end1, beg2, end2, dest, comp); // ä¸¤ä¸ªè¾“å…¥åºåˆ—å¿…é¡»éƒ½æ˜¯æœ‰åºçš„ï¼Œä½¿ç”¨ç»™å®šçš„æ¯”è¾ƒæ“ä½œï¼ˆcompï¼‰å°†åˆå¹¶åçš„åºåˆ—å†™å…¥åˆ° dest ä¸­

// ä½¿ç”¨å‰å‘è¿­ä»£å™¨çš„å†™ç®—æ³•ï¼Œè¦æ±‚å‰å‘è¿­ä»£å™¨
iter_swap(iter1, iter2); // äº¤æ¢ iter1 å’Œ iter2 æ‰€è¡¨ç¤ºçš„å…ƒç´ ï¼Œè¿”å› void
swap_ranges(beg1, end1, beg2); // å°†è¾“å…¥èŒƒå›´ä¸­æ‰€æœ‰å…ƒç´ ä¸ beg2 å¼€å§‹çš„ç¬¬äºŒä¸ªåºåˆ—ä¸­æ‰€æœ‰å…ƒç´ è¿›è¡Œäº¤æ¢ã€‚è¿”å›é€’å¢åçš„çš„ beg2ï¼ŒæŒ‡å‘æœ€åä¸€ä¸ªäº¤æ¢å…ƒç´ ä¹‹åçš„ä½ç½®ã€‚
replace(beg, end, old_val, new_val); // ç”¨ new_val æ›¿æ¢ç­‰äº old_val çš„æ¯ä¸ªåŒ¹é…å…ƒç´ 
replace_if(beg, end, unaryPred, new_val); // ç”¨ new_val æ›¿æ¢æ»¡è¶³ unaryPred çš„æ¯ä¸ªåŒ¹é…å…ƒç´ 

// ä½¿ç”¨åŒå‘è¿­ä»£å™¨çš„å†™ç®—æ³•ï¼Œè¦æ±‚åŒå‘é€‰ä»£å™¨ï¼ˆbidirectional iteratorï¼‰
copy_backward(beg, end, dest); // ä»è¾“å…¥èŒƒå›´ä¸­æ‹·è´å…ƒç´ åˆ°æŒ‡å®šç›®çš„ä½ç½®ã€‚å¦‚æœèŒƒå›´ä¸ºç©º,åˆ™è¿”å›å€¼ä¸º destï¼›å¦åˆ™ï¼Œè¿”å›å€¼è¡¨ç¤ºä» *beg ä¸­æ‹·è´æˆ–ç§»åŠ¨çš„å…ƒç´ ã€‚
move_backward(beg, end, dest);  // ä»è¾“å…¥èŒƒå›´ä¸­ç§»åŠ¨å…ƒç´ åˆ°æŒ‡å®šç›®çš„ä½ç½®ã€‚å¦‚æœèŒƒå›´ä¸ºç©º,åˆ™è¿”å›å€¼ä¸º destï¼›å¦åˆ™,è¿”å›å€¼è¡¨ç¤ºä» *beg ä¸­æ‹·è´æˆ–ç§»åŠ¨çš„å…ƒç´ ã€‚
inplace_merge(beg, mid, end); // å°†åŒä¸€ä¸ªåºåˆ—ä¸­çš„ä¸¤ä¸ªæœ‰åºå­åºåˆ—åˆå¹¶ä¸ºå•ä¸€çš„æœ‰åºåºåˆ—ã€‚beg åˆ° mid é—´çš„å­åºåˆ—å’Œ mid åˆ° end é—´çš„å­åºåˆ—è¢«åˆå¹¶ï¼Œå¹¶è¢«å†™å…¥åˆ°åŸåºåˆ—ä¸­ã€‚ä½¿ç”¨ < æ¯”è¾ƒå…ƒç´ ã€‚
inplace_merge(beg, mid, end, comp); // å°†åŒä¸€ä¸ªåºåˆ—ä¸­çš„ä¸¤ä¸ªæœ‰åºå­åºåˆ—åˆå¹¶ä¸ºå•ä¸€çš„æœ‰åºåºåˆ—ã€‚beg åˆ° mid é—´çš„å­åºåˆ—å’Œ mid åˆ° end é—´çš„å­åºåˆ—è¢«åˆå¹¶ï¼Œå¹¶è¢«å†™å…¥åˆ°åŸåºåˆ—ä¸­ã€‚ä½¿ç”¨ç»™å®šçš„ comp æ“ä½œã€‚

// åˆ’åˆ†ç®—æ³•ï¼Œè¦æ±‚åŒå‘é€‰ä»£å™¨ï¼ˆbidirectional iteratorï¼‰
is_partitioned(beg, end, unaryPred); // å¦‚æœæ‰€æœ‰æ»¡è¶³è°“è¯ unaryPred çš„å…ƒç´ éƒ½åœ¨ä¸æ»¡è¶³ unarypred çš„å…ƒç´ ä¹‹å‰ï¼Œåˆ™è¿”å› trueã€‚è‹¥åºåˆ—ä¸ºç©ºï¼Œä¹Ÿè¿”å› true
partition_copy(beg, end, dest1, dest2, unaryPred); // å°†æ»¡è¶³ unaryPred çš„å…ƒç´ æ‹·è´åˆ°åˆ° dest1ï¼Œå¹¶å°†ä¸æ»¡è¶³ unaryPred çš„å…ƒç´ æ‹·è´åˆ°åˆ° dest2ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ pairï¼Œå…¶ first æˆå‘˜è¡¨ç¤ºæ‹·è´åˆ° dest1 çš„çš„å…ƒç´ çš„æœ«å°¾ï¼Œsecond è¡¨ç¤ºæ‹·è´åˆ° dest2 çš„å…ƒç´ çš„æœ«å°¾ã€‚
partitioned_point(beg, end, unaryPred); // è¾“å…¥åºåˆ—å¿…é¡»æ˜¯å·²ç»ç”¨ unaryPred åˆ’åˆ†è¿‡çš„ã€‚è¿”å›æ»¡è¶³  unaryPred çš„èŒƒå›´çš„å°¾åè¿­ä»£å™¨ã€‚å¦‚æœè¿”å›çš„è¿­ä»£å™¨ä¸æ˜¯ endï¼Œåˆ™å®ƒæŒ‡å‘çš„å…ƒç´ åŠå…¶åçš„å…ƒç´ å¿…é¡»éƒ½ä¸æ»¡è¶³ unaryPred
stable_partition(beg, end, unaryPred); // ä½¿ç”¨ unaryPred åˆ’åˆ†è¾“å…¥åºåˆ—ã€‚æ»¡è¶³ unaryPred çš„å…ƒç´ æ”¾ç½®åœ¨åºåˆ—å¼€å§‹ï¼Œä¸æ»¡è¶³çš„å…ƒç´ æ”¾åœ¨åºåˆ—å°¾éƒ¨ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘æœ€åä¸€ä¸ªæ»¡è¶³ unaryPred çš„å…ƒç´ ä¹‹åçš„ä½ç½®å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½ä¸æ»¡è¶³ unaryPredï¼Œåˆ™è¿”å› beg
partition(beg, end, unaryPred); // ä½¿ç”¨ unaryPred åˆ’åˆ†è¾“å…¥åºåˆ—ã€‚æ»¡è¶³ unaryPred çš„å…ƒç´ æ”¾ç½®åœ¨åºåˆ—å¼€å§‹ï¼Œä¸æ»¡è¶³çš„å…ƒç´ æ”¾åœ¨åºåˆ—å°¾éƒ¨ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘æœ€åä¸€ä¸ªæ»¡è¶³ unaryPred çš„å…ƒç´ ä¹‹åçš„ä½ç½®å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½ä¸æ»¡è¶³ unaryPredï¼Œåˆ™è¿”å› beg

// æ’åºç®—æ³•ï¼Œè¦æ±‚éšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆrandom-access iteratorï¼‰
sort(beg, end); // æ’åºæ•´ä¸ªèŒƒå›´
stable_sort(beg, end); // æ’åºæ•´ä¸ªèŒƒå›´ï¼ˆç¨³å®šæ’åºï¼‰
sort(beg, end, comp); // æ’åºæ•´ä¸ªèŒƒå›´
stable_sort(beg, end, comp); // æ’åºæ•´ä¸ªèŒƒå›´ï¼ˆç¨³å®šæ’åºï¼‰
is_sorted(beg, end); // è¿”å›ä¸€ä¸ª bool å€¼ï¼ŒæŒ‡å‡ºæ•´ä¸ªè¾“å…¥åºåˆ—æ˜¯å¦æœ‰åº
is_sorted(beg, end, comp); // è¿”å›ä¸€ä¸ª bool å€¼ï¼ŒæŒ‡å‡ºæ•´ä¸ªè¾“å…¥åºåˆ—æ˜¯å¦æœ‰åº
is_sorted_until(beg, end); // åœ¨è¾“å…¥åºåˆ—ä¸­æŸ»æ‰¾æœ€é•¿åˆå§‹æœ‰åºå­åºåˆ—ï¼Œå¹¶è¿”å›å­åºåˆ—çš„å°¾åè¿­ä»£å™¨
is_sorted_until(beg, end, comp); // åœ¨è¾“å…¥åºåˆ—ä¸­æŸ»æ‰¾æœ€é•¿åˆå§‹æœ‰åºå­åºåˆ—ï¼Œå¹¶è¿”å›å­åºåˆ—çš„å°¾åè¿­ä»£å™¨
partial_sort(beg, mid, end); // æ’åº mid-beg ä¸ªå…ƒç´ ã€‚å³ï¼Œå¦‚æœ mid-beg ç­‰äº 42ï¼Œåˆ™æ­¤å‡½æ•°å°†å€¼æœ€å°çš„ 42 ä¸ªå…ƒç´ æœ‰åºæ”¾åœ¨åºåˆ—å‰ 42 ä¸ªä½ç½®
partial_sort(beg, mid, end, comp); // æ’åº mid-beg ä¸ªå…ƒç´ ã€‚å³ï¼Œå¦‚æœ mid-beg ç­‰äº 42ï¼Œåˆ™æ­¤å‡½æ•°å°†å€¼æœ€å°çš„ 42 ä¸ªå…ƒç´ æœ‰åºæ”¾åœ¨åºåˆ—å‰ 42 ä¸ªä½ç½®
partial_sort_copy(beg, end, destBeg, destEnd); // æ’åºè¾“å…¥èŒƒå›´ä¸­çš„å…ƒç´ ï¼Œå¹¶å°†è¶³å¤Ÿå¤šçš„å·²æ’åºå…ƒç´ æ”¾åˆ° destBeg å’Œ destEnd æ‰€æŒ‡ç¤ºçš„åºåˆ—ä¸­
partial_sort_copy(beg, end, destBeg, destEnd, comp); // æ’åºè¾“å…¥èŒƒå›´ä¸­çš„å…ƒç´ ï¼Œå¹¶å°†è¶³å¤Ÿå¤šçš„å·²æ’åºå…ƒç´ æ”¾åˆ° destBeg å’Œ destEnd æ‰€æŒ‡ç¤ºçš„åºåˆ—ä¸­
nth_element(beg, nth, end); // nth æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘è¾“å…¥åºåˆ—ä¸­ç¬¬ n å¤§çš„å…ƒç´ ã€‚nth ä¹‹å‰çš„å…ƒç´ éƒ½å°äºç­‰äºå®ƒï¼Œè€Œä¹‹åçš„å…ƒç´ éƒ½å¤§äºç­‰äºå®ƒ
nth_element(beg, nth, end, comp); // nth æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘è¾“å…¥åºåˆ—ä¸­ç¬¬ n å¤§çš„å…ƒç´ ã€‚nth ä¹‹å‰çš„å…ƒç´ éƒ½å°äºç­‰äºå®ƒï¼Œè€Œä¹‹åçš„å…ƒç´ éƒ½å¤§äºç­‰äºå®ƒ

// ä½¿ç”¨å‰å‘è¿­ä»£å™¨çš„é‡æ’ç®—æ³•ã€‚æ™®é€šç‰ˆæœ¬åœ¨è¾“å…¥åºåˆ—è‡ªèº«å†…éƒ¨é‡æ‹å…ƒç´ ï¼Œ_copy ç‰ˆæœ¬å®Œæˆé‡æ‹åå†™å…¥åˆ°æŒ‡å®šç›®çš„åºåˆ—ä¸­ï¼Œè€Œä¸æ”¹å˜è¾“å…¥åºåˆ—
remove(beg, end, val); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤ ==val çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
remove_if(beg, end, unaryPred); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤æ»¡è¶³ unaryPred çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
remove_copy(beg, end, dest, val); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤ ==val çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
remove_copy_if(beg, end, dest, unaryPred); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤æ»¡è¶³ unaryPred çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
unique(beg, end); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ == ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
unique (beg, end, binaryPred); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ binaryPred ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
unique_copy(beg, end, dest); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ == ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
unique_copy_if(beg, end, dest, binaryPred); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ binaryPred ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
rotate(beg, mid, end); // å›´ç»• mid æŒ‡å‘çš„å…ƒç´ è¿›è¡Œå…ƒç´ è½¬åŠ¨ã€‚å…ƒç´  mid æˆä¸ºä¸ºé¦–å…ƒç´ ï¼Œéšåæ˜¯ mid+1 åˆ°åˆ° end ä¹‹å‰çš„å…ƒç´ ï¼Œå†æ¥ç€æ˜¯ beg åˆ° mid ä¹‹å‰çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘åŸæ¥åœ¨ beg ä½ç½®çš„å…ƒç´ 
rotate_copy(beg, mid, end, dest); // å›´ç»• mid æŒ‡å‘çš„å…ƒç´ è¿›è¡Œå…ƒç´ è½¬åŠ¨ã€‚å…ƒç´  mid æˆä¸ºä¸ºé¦–å…ƒç´ ï¼Œéšåæ˜¯ mid+1 åˆ°åˆ° end ä¹‹å‰çš„å…ƒç´ ï¼Œå†æ¥ç€æ˜¯ beg åˆ° mid ä¹‹å‰çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘åŸæ¥åœ¨ beg ä½ç½®çš„å…ƒç´ 

// ä½¿ç”¨åŒå‘è¿­ä»£å™¨çš„é‡æ’ç®—æ³•
reverse(beg, end); // ç¿»è½¬åºåˆ—ä¸­çš„å…ƒç´ ï¼Œè¿”å› void
reverse_copy(beg, end, dest);; // ç¿»è½¬åºåˆ—ä¸­çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘æ‹·è´åˆ°ç›®çš„åºåˆ—çš„å…ƒç´ çš„å°¾åä½ç½®

// ä½¿ç”¨éšæœºè®¿é—®è¿­ä»£å™¨çš„é‡æ’ç®—æ³•
random_shuffle(beg, end); // æ··æ´—è¾“å…¥åºåˆ—ä¸­çš„å…ƒç´ ï¼Œè¿”å› void
random_shuffle(beg, end, rand); // æ··æ´—è¾“å…¥åºåˆ—ä¸­çš„å…ƒç´ ï¼Œrand æ¥å—ä¸€ä¸ªæ­£æ•´æ•°çš„éšæœºå¯¹è±¡ï¼Œè¿”å› void
shuffle(beg, end, Uniform_rand); // æ··æ´—è¾“å…¥åºåˆ—ä¸­çš„å…ƒç´ ï¼ŒUniform_rand å¿…é¡»æ»¡è¶³å‡åŒ€åˆ†å¸ƒéšæœºæ•°ç”Ÿæˆå™¨çš„è¦æ±‚ï¼Œè¿”å› void

// æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œä½¿ç”¨ < è¿ç®—ç¬¦æˆ–ç»™å®šçš„æ¯”è¾ƒæ“ä½œ comp è¿›è¡Œæ¯”è¾ƒ
min(val1, va12); // è¿”å› val1 å’Œ val2 ä¸­çš„æœ€å°å€¼ï¼Œä¸¤ä¸ªå®å‚çš„ç±»å‹å¿…é¡»å®Œå…¨ä¸€è‡´ã€‚å‚æ•°å’Œè¿”å›ç±»å‹éƒ½æ˜¯ constçš„å¼•å¼•ç”¨ï¼Œæ„å‘³ç€å¯¹è±¡ä¸ä¼šè¢«æ‹·è´ã€‚ä¸‹ç•¥
min(val1, val2, comp);
min(init_list);
min(init_list, comp);
max(val1, val2);
max(val1, val2, comp);
max(init_list);
max(init_list, comp);
minmax(val1, val2); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ first æˆå‘˜ä¸ºæä¾›çš„å€¼ä¸­çš„è¾ƒå°è€…ï¼Œsecond æˆå‘˜ä¸ºè¾ƒå¤§è€…ã€‚ä¸‹ç•¥
minmax(vall, val2, comp);
minmax(init_list);
minmax(init_list, comp);
min_element(beg, end); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å°å…ƒç´ çš„è¿­ä»£å™¨
min_element(beg, end, comp); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å°å…ƒç´ çš„è¿­ä»£å™¨
max_element(beg, end); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å¤§å…ƒç´ çš„è¿­ä»£å™¨
max_element(beg, end, comp); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å¤§å…ƒç´ çš„è¿­ä»£å™¨
minmax_element(beg, end); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ä¸­ first æˆå‘˜ä¸ºæœ€å°å…ƒç´ ï¼Œsecond æˆå‘˜ä¸ºæœ€å¤§å…ƒç´ 
minmax_element(beg, end, comp); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ä¸­ first æˆå‘˜ä¸ºæœ€å°å…ƒç´ ï¼Œsecond æˆå‘˜ä¸ºæœ€å¤§å…ƒç´ 

// å­—å…¸åºæ¯”è¾ƒï¼Œæ ¹æ®ç¬¬ä¸€å¯¹ä¸ç›¸ç­‰çš„å…ƒç´ çš„ç›¸å¯¹å¤§å°æ¥è¿”å›ç»“æœã€‚å¦‚æœç¬¬ä¸€ä¸ªåºåˆ—åœ¨å­—å…¸åºä¸­å°äºç¬¬äºŒä¸ªåºåˆ—ï¼Œåˆ™è¿”å› trueã€‚å¦åˆ™ï¼Œè¿”å› fa1seã€‚å¦‚æœä¸ªåºåˆ—æ¯”å¦ä¸€ä¸ªçŸ­ï¼Œä¸”æ‰€æœ‰å…ƒç´ éƒ½ä¸è¾ƒé•¿åºåˆ—çš„å¯¹åº”å…ƒç´ ç›¸ç­‰ï¼Œåˆ™è¾ƒçŸ­åºåˆ—åœ¨å­—å…¸åºä¸­æ›´å°ã€‚å¦‚æœåºåˆ—é•¿åº¦ç›¸ç­‰ï¼Œä¸”å¯¹åº”å…ƒç´ éƒ½ç›¸ç­‰ï¼Œåˆ™åœ¨å­—å…¸åºä¸­ä»»ä½•ä¸€ä¸ªéƒ½ä¸å¤§äºå¦å¤–ä¸€ä¸ªã€‚
lexicographical_compare(beg1, end1, beg2, end2);
lexicographical_compare(beg1, end1, beg2, end2, comp);
```

# STL

## ç½‘ç«™

* [github . huihut/note/STL.md](https://github.com/huihut/note/blob/master/STL.md)
* [cplusplus . stl](http://www.cplusplus.com/reference/stl/)
* [cppreference . C++ å‚è€ƒæ‰‹å†Œ](http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)
* [CSDNä¸“æ ï¼šSTLå­¦ä¹ ç¬”è®°](http://blog.csdn.net/column/details/geek-stl.html)

## ç»„æˆ

* å®¹å™¨ï¼ˆcontainersï¼‰
* ç®—æ³•ï¼ˆalgorithmsï¼‰
* è¿­ä»£å™¨ï¼ˆiteratorsï¼‰
* ä»¿å‡½æ•°ï¼ˆfunctorsï¼‰
* é…æ¥å™¨ï¼ˆadaptersï¼‰
* ç©ºé—´é…ç½®å™¨ï¼ˆallocatorï¼‰

## å®¹å™¨ï¼ˆcontainersï¼‰

* åºåˆ—å¼å®¹å™¨ï¼ˆsequence containersï¼‰ï¼šå…ƒç´ éƒ½æ˜¯å¯åºï¼ˆorderedï¼‰ï¼Œä½†æœªå¿…æ˜¯æœ‰åºï¼ˆsortedï¼‰
* å…³è”å¼å®¹å™¨ï¼ˆassociattive containersï¼‰

### array

arrayæ˜¯å›ºå®šå¤§å°çš„é¡ºåºå®¹å™¨ï¼Œå®ƒä»¬ä¿å­˜äº†ä¸€ä¸ªä»¥ä¸¥æ ¼çš„çº¿æ€§é¡ºåºæ’åˆ—çš„ç‰¹å®šæ•°é‡çš„å…ƒç´ ã€‚

åœ¨å†…éƒ¨ï¼Œä¸€ä¸ªæ•°ç»„é™¤äº†å®ƒæ‰€åŒ…å«çš„å…ƒç´ ï¼ˆç”šè‡³ä¸æ˜¯å®ƒçš„å¤§å°ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ¨¡æ¿å‚æ•°ï¼Œåœ¨ç¼–è¯‘æ—¶æ˜¯å›ºå®šçš„ï¼‰ä»¥å¤–ä¸ä¿å­˜ä»»ä½•æ•°æ®ã€‚å­˜å‚¨å¤§å°ä¸ç”¨è¯­è¨€æ‹¬å·è¯­æ³•ï¼ˆ[]ï¼‰å£°æ˜çš„æ™®é€šæ•°ç»„ä¸€æ ·é«˜æ•ˆã€‚è¿™ä¸ªç±»åªæ˜¯å¢åŠ äº†ä¸€å±‚æˆå‘˜å‡½æ•°å’Œå…¨å±€å‡½æ•°ï¼Œæ‰€ä»¥æ•°ç»„å¯ä»¥ä½œä¸ºæ ‡å‡†å®¹å™¨ä½¿ç”¨ã€‚

ä¸å…¶ä»–æ ‡å‡†å®¹å™¨ä¸åŒï¼Œæ•°ç»„å…·æœ‰å›ºå®šçš„å¤§å°ï¼Œå¹¶ä¸”ä¸é€šè¿‡åˆ†é…å™¨ç®¡ç†å…¶å…ƒç´ çš„åˆ†é…ï¼šå®ƒä»¬æ˜¯å°è£…å›ºå®šå¤§å°æ•°ç»„å…ƒç´ çš„èšåˆç±»å‹ã€‚å› æ­¤ï¼Œä»–ä»¬ä¸èƒ½åŠ¨æ€åœ°æ‰©å¤§æˆ–ç¼©å°ã€‚

é›¶å¤§å°çš„æ•°ç»„æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯å®ƒä»¬ä¸åº”è¯¥è¢«è§£é™¤å¼•ç”¨ï¼ˆæˆå‘˜çš„å‰é¢ï¼Œåé¢å’Œæ•°æ®ï¼‰ã€‚

ä¸æ ‡å‡†åº“ä¸­çš„å…¶ä»–å®¹å™¨ä¸åŒï¼Œäº¤æ¢ä¸¤ä¸ªæ•°ç»„å®¹å™¨æ˜¯ä¸€ç§çº¿æ€§æ“ä½œï¼Œå®ƒæ¶‰åŠå•ç‹¬äº¤æ¢èŒƒå›´å†…çš„æ‰€æœ‰å…ƒç´ ï¼Œè¿™é€šå¸¸æ˜¯ç›¸å½“ä½æ•ˆçš„æ“ä½œã€‚å¦ä¸€æ–¹é¢ï¼Œè¿™å…è®¸è¿­ä»£å™¨åœ¨ä¸¤ä¸ªå®¹å™¨ä¸­çš„å…ƒç´ ä¿æŒå…¶åŸå§‹å®¹å™¨å…³è”ã€‚

æ•°ç»„å®¹å™¨çš„å¦ä¸€ä¸ªç‹¬ç‰¹ç‰¹æ€§æ˜¯å®ƒä»¬å¯ä»¥è¢«å½“ä½œå…ƒç»„å¯¹è±¡æ¥å¤„ç†ï¼šarrayå¤´éƒ¨é‡è½½getå‡½æ•°æ¥è®¿é—®æ•°ç»„å…ƒç´ ï¼Œå°±åƒå®ƒæ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œä»¥åŠä¸“é—¨çš„tuple_sizeå’Œtuple_elementç±»å‹ã€‚

```cpp
template < class T, size_t N > class array;
```

![](assets/stlæ€»ç»“/20160405225541788)

#### array::begin

è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚

![](https://i.stack.imgur.com/oa3EQ.png)

```cpp
      iterator begin() noexcept;
const_iterator begin() const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main()
{
    std::array<int, 5> myarray = {2, 16, 77,34, 50};
    std::cout << "myarray contains:";
    for(auto it = myarray.begin(); it != myarray.end(); ++it)
        std::cout << ' ' << *it;
    std::cout << '\n';

    return 0;
}
```

Output

```
myarray contains: 2 16 77 34 50
```

#### array::end

è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åçš„ç†è®ºå…ƒç´ çš„è¿­ä»£å™¨ã€‚

```cpp
      iterator end() noexcept;
const_iterator end() const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,5> myarray = { 5, 19, 77, 34, 99 };

    std::cout << "myarray contains:";
    for ( auto it = myarray.begin(); it != myarray.end(); ++it )
        std::cout << ' ' << *it;

    std::cout << '\n';

    return 0;
}
```

Output

```
myarray contains: 5 19 77 34 99
```

#### array::rbegin

è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„åå‘è¿­ä»£å™¨ã€‚

```cpp
      reverse_iterator rbeginï¼ˆï¼‰noexcept;
const_reverse_iterator rbeginï¼ˆï¼‰const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,4> myarray = {4, 26, 80, 14} ;
    for(auto rit = myarray.rbegin(); rit < myarray.rend(); ++rit)
        std::cout << ' ' << *rit;
    
    std::cout << '\n';

    return 0;
}
```

Output

```
myarray contains: 14 80 26 4
```

#### array::rend

è¿”å›ä¸€ä¸ªåå‘è¿­ä»£å™¨ï¼ŒæŒ‡å‘æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ç†è®ºå…ƒç´ ï¼ˆè¿™è¢«è®¤ä¸ºæ˜¯å®ƒçš„åå‘ç»“æŸï¼‰ã€‚

```cpp
      reverse_iterator rend() noexcept;
const_reverse_iterator rend() const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,4> myarray = {4, 26, 80, 14};
    std::cout << "myarray contains";
    for(auto rit = myarray.rbegin(); rit < myarray.rend(); ++rit)
        std::cout << ' ' << *rit;
    
    std::cout << '\n';

    return 0;
}
```

Output

```
myarray contains: 14 80 26 4
```

#### array::cbegin

è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¸¸é‡è¿­ä»£å™¨ï¼ˆconst_iteratorï¼‰ï¼›è¿™ä¸ªè¿­ä»£å™¨å¯ä»¥å¢åŠ å’Œå‡å°‘ï¼Œä½†æ˜¯ä¸èƒ½ç”¨æ¥ä¿®æ”¹å®ƒæŒ‡å‘çš„å†…å®¹ã€‚

```cpp
const_iterator cbeginï¼ˆï¼‰const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,5> myarray = {2, 16, 77, 34, 50};
    
    std::cout << "myarray contains:";

    for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it )
        std::cout << ' ' << *it;   // cannot modify *it

    std::cout << '\n';

    return 0;
}
```

Output

```
myarray contains: 2 16 77 34 50
```

#### array::cend

è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åçš„ç†è®ºå…ƒç´ çš„å¸¸é‡è¿­ä»£å™¨ï¼ˆconst_iteratorï¼‰ã€‚è¿™ä¸ªè¿­ä»£å™¨å¯ä»¥å¢åŠ å’Œå‡å°‘ï¼Œä½†æ˜¯ä¸èƒ½ç”¨æ¥ä¿®æ”¹å®ƒæŒ‡å‘çš„å†…å®¹ã€‚

```cpp
const_iterator cend() const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,5> myarray = { 15, 720, 801, 1002, 3502 };

    std::cout << "myarray contains:";
    for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it )
        std::cout << ' ' << *it;   // cannot modify *it

    std::cout << '\n';

    return 0;
}
```

Output

```
myarray contains: 2 16 77 34 50
```

#### array::crbegin

è¿”å›æŒ‡å‘æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¸¸é‡åå‘è¿­ä»£å™¨ï¼ˆconst_reverse_iteratorï¼‰

```cpp
const_reverse_iterator crbeginï¼ˆï¼‰const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,6> myarray = {10, 20, 30, 40, 50, 60} ;

    std::cout << "myarray backwards:";
    for ( auto rit=myarray.crbegin() ; rit < myarray.crend(); ++rit )
        std::cout << ' ' << *rit;   // cannot modify *rit

    std::cout << '\n';

    return 0;
}
```

Output

```
myarray backwards: 60 50 40 30 20 10
```

#### array::crend

è¿”å›æŒ‡å‘æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ç†è®ºå…ƒç´ çš„å¸¸é‡åå‘è¿­ä»£å™¨ï¼ˆconst_reverse_iteratorï¼‰ï¼Œå®ƒè¢«è®¤ä¸ºæ˜¯å…¶åå‘ç»“æŸã€‚

```cpp
const_reverse_iterator crend() const noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,6> myarray = {10, 20, 30, 40, 50, 60} ;

    std::cout << "myarray backwards:";
    for ( auto rit=myarray.crbegin() ; rit < myarray.crend(); ++rit )
        std::cout << ' ' << *rit;   // cannot modify *rit

    std::cout << '\n';

    return 0;
}
```

Output

```
myarray backwards: 60 50 40 30 20 10
```

#### array::size

è¿”å›æ•°ç»„å®¹å™¨ä¸­å…ƒç´ çš„æ•°é‡ã€‚

```cpp
constexpr size_type sizeï¼ˆï¼‰noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,5> myints;
    std::cout << "size of myints:" << myints.size() << std::endl;
    std::cout << "sizeof(myints):" << sizeof(myints) << std::endl;

    return 0;
}
```

Possible Output

```
size of myints: 5
sizeof(myints): 20
```

#### array::max_size

è¿”å›æ•°ç»„å®¹å™¨å¯å®¹çº³çš„æœ€å¤§å…ƒç´ æ•°ã€‚æ•°ç»„å¯¹è±¡çš„max_sizeä¸å…¶sizeä¸€æ ·ï¼Œå§‹ç»ˆç­‰äºç”¨äºå®ä¾‹åŒ–æ•°ç»„æ¨¡æ¿ç±»çš„ç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•°ã€‚

```cpp
constexpr size_type max_size() noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,10> myints;
    std::cout << "size of myints: " << myints.size() << '\n';
    std::cout << "max_size of myints: " << myints.max_size() << '\n';

    return 0;
}
```

Output

```
size of myints: 10
max_size of myints: 10
```

#### array::empty

è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼ŒæŒ‡ç¤ºæ•°ç»„å®¹å™¨æ˜¯å¦ä¸ºç©ºï¼Œå³å®ƒçš„size()æ˜¯å¦ä¸º0ã€‚

```cpp
constexpr bool empty() noexcept;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
  std::array<int,0> first;
  std::array<int,5> second;
  std::cout << "first " << (first.empty() ? "is empty" : "is not empty") << '\n';
  std::cout << "second " << (second.empty() ? "is empty" : "is not empty") << '\n';
  return 0;
}
```

Output:

```
first is empty
second is not empt
```

#### array::operator[]

è¿”å›æ•°ç»„ä¸­ç¬¬nä¸ªä½ç½®çš„å…ƒç´ çš„å¼•ç”¨ã€‚ä¸array::atç›¸ä¼¼ï¼Œä½†array::atä¼šæ£€æŸ¥æ•°ç»„è¾¹ç•Œå¹¶é€šè¿‡æŠ›å‡ºä¸€ä¸ªout_of_rangeå¼‚å¸¸æ¥åˆ¤æ–­næ˜¯å¦è¶…å‡ºèŒƒå›´ï¼Œè€Œarray::operator[]ä¸æ£€æŸ¥è¾¹ç•Œã€‚

```cpp
      reference operator[] (size_type n);
const_reference operator[] (size_type n) const;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
    std::array<int,10> myarray;
    unsigned int i;

    // assign some values:
    for(i=0; i<10; i++)
        myarray[i] = i;

    // print content
    std::cout << "myarray contains:";
    for(i=0; i<10; i++)
        std::cout << ' ' << myarray[i];
    std::cout << '\n';

    return 0;
}
```

Output

```
myarray contains: 0 1 2 3 4 5 6 7 8 9
```

#### array::at

è¿”å›æ•°ç»„ä¸­ç¬¬nä¸ªä½ç½®çš„å…ƒç´ çš„å¼•ç”¨ã€‚ä¸array::operator[]ç›¸ä¼¼ï¼Œä½†array::atä¼šæ£€æŸ¥æ•°ç»„è¾¹ç•Œå¹¶é€šè¿‡æŠ›å‡ºä¸€ä¸ªout_of_rangeå¼‚å¸¸æ¥åˆ¤æ–­næ˜¯å¦è¶…å‡ºèŒƒå›´ï¼Œè€Œarray::operator[]ä¸æ£€æŸ¥è¾¹ç•Œã€‚

```cpp
      reference at ( size_type n );
const_reference at ( size_type n ) const;
```

Example

```cpp
#include <iostream>
#include <array>

int main()
{
	std::array<int, 10> myarray;
	unsigned int i;

	// assign some values:
	for (i = 0; i<10; i++)
		myarray[i] = i;

	// print content
	std::cout << "myarray contains:";
	for (i = 0; i<10; i++)
		std::cout << ' ' << myarray.at(i);
	std::cout << '\n';

	return 0;
}
```

Output

```
myarray contains: 0 1 2 3 4 5 6 7 8 9
```

#### array::front

è¿”å›å¯¹æ•°ç»„å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ã€‚array::beginè¿”å›çš„æ˜¯è¿­ä»£å™¨ï¼Œarray::frontè¿”å›çš„æ˜¯ç›´æ¥å¼•ç”¨ã€‚  
åœ¨ç©ºå®¹å™¨ä¸Šè°ƒç”¨æ­¤å‡½æ•°ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚

```cpp
      reference front();
const_reference front() const;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
  std::array<int,3> myarray = {2, 16, 77};

  std::cout << "front is: " << myarray.front() << std::endl;   // 2
  std::cout << "back is: " << myarray.back() << std::endl;     // 77

  myarray.front() = 100;

  std::cout << "myarray now contains:";
  for ( int& x : myarray ) std::cout << ' ' << x;

  std::cout << '\n';

  return 0;
}
```

Output

```
front is: 2
back is: 77
myarray now contains: 100 16 77
```

#### array::back

è¿”å›å¯¹æ•°ç»„å®¹å™¨ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ã€‚array::endè¿”å›çš„æ˜¯è¿­ä»£å™¨ï¼Œarray::backè¿”å›çš„æ˜¯ç›´æ¥å¼•ç”¨ã€‚  
åœ¨ç©ºå®¹å™¨ä¸Šè°ƒç”¨æ­¤å‡½æ•°ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚

```cpp
      reference back();
const_reference back() const;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
  std::array<int,3> myarray = {5, 19, 77};

  std::cout << "front is: " << myarray.front() << std::endl;   // 5
  std::cout << "back is: " << myarray.back() << std::endl;     // 77

  myarray.back() = 50;

  std::cout << "myarray now contains:";
  for ( int& x : myarray ) std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```

Output

```
front is: 5
back is: 77
myarray now contains: 5 19 50
```

#### array::data

è¿”å›æŒ‡å‘æ•°ç»„å¯¹è±¡ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆã€‚

ç”±äºæ•°ç»„ä¸­çš„å…ƒç´ å­˜å‚¨åœ¨è¿ç»­çš„å­˜å‚¨ä½ç½®ï¼Œæ‰€ä»¥æ£€ç´¢åˆ°çš„æŒ‡é’ˆå¯ä»¥åç§»ä»¥è®¿é—®æ•°ç»„ä¸­çš„ä»»ä½•å…ƒç´ ã€‚

```cpp
      value_type* data() noexcept;
const value_type* data() const noexcept;
```

Example

```cpp
#include <iostream>
#include <cstring>
#include <array>

int main ()
{
  const char* cstr = "Test string";
  std::array<char,12> charray;

  std::memcpy (charray.data(),cstr,12);

  std::cout << charray.data() << '\n';

  return 0;
}
```

Output

```
Test string
```

#### array::fill

ç”¨valå¡«å……æ•°ç»„æ‰€æœ‰å…ƒç´ ï¼Œå°†valè®¾ç½®ä¸ºæ•°ç»„å¯¹è±¡ä¸­æ‰€æœ‰å…ƒç´ çš„å€¼ã€‚

```cpp
void fill (const value_type& val);
```

Example

```cpp
#include <iostream>
#include <array>

int main () {
  std::array<int,6> myarray;

  myarray.fill(5);

  std::cout << "myarray contains:";
  for ( int& x : myarray) { std::cout << ' ' << x; }

  std::cout << '\n';

  return 0;
}
```

Output

```
myarray contains: 5 5 5 5 5 5
```

#### array::swap

é€šè¿‡xçš„å†…å®¹äº¤æ¢æ•°ç»„çš„å†…å®¹ï¼Œè¿™æ˜¯å¦ä¸€ä¸ªç›¸åŒç±»å‹çš„æ•°ç»„å¯¹è±¡ï¼ˆåŒ…æ‹¬ç›¸åŒçš„å¤§å°ï¼‰ã€‚

ä¸å…¶ä»–å®¹å™¨çš„äº¤æ¢æˆå‘˜å‡½æ•°ä¸åŒï¼Œæ­¤æˆå‘˜å‡½æ•°é€šè¿‡åœ¨å„ä¸ªå…ƒç´ ä¹‹é—´æ‰§è¡Œä¸å…¶å¤§å°ç›¸åŒçš„å•ç‹¬äº¤æ¢æ“ä½œï¼Œä»¥çº¿æ€§æ—¶é—´è¿è¡Œã€‚

```cpp
void swap (array& x) noexcept(noexcept(swap(declval<value_type&>(),declval<value_type&>())));
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
  std::array<int,5> first = {10, 20, 30, 40, 50};
  std::array<int,5> second = {11, 22, 33, 44, 55};

  first.swap (second);

  std::cout << "first:";
  for (int& x : first) std::cout << ' ' << x;
  std::cout << '\n';

  std::cout << "second:";
  for (int& x : second) std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```

Output

```
first: 11 22 33 44 55
second: 10 20 30 40 50
```

#### getï¼ˆarrayï¼‰

å½¢å¦‚ï¼šstd::get<0>(myarray)ï¼›ä¼ å…¥ä¸€ä¸ªæ•°ç»„å®¹å™¨ï¼Œè¿”å›æŒ‡å®šä½ç½®å…ƒç´ çš„å¼•ç”¨ã€‚

```cpp
template <size_t Iï¼Œclass Tï¼Œsize_t N> Tï¼†getï¼ˆarray <Tï¼ŒN>ï¼†arrï¼‰noexcept; 
template <size_t Iï¼Œclass Tï¼Œsize_t N> T && getï¼ˆarray <Tï¼ŒN> && arrï¼‰noexcept; 
template <size_t Iï¼Œclass Tï¼Œsize_t N> const Tï¼†getï¼ˆconst array <Tï¼ŒN>ï¼†arrï¼‰noexcept;
```

Example

```cpp
#include <iostream>
#include <array>
#include <tuple>

int main ()
{
  std::array<int,3> myarray = {10, 20, 30};
  std::tuple<int,int,int> mytuple (10, 20, 30);

  std::tuple_element<0,decltype(myarray)>::type myelement;  // int myelement

  myelement = std::get<2>(myarray);
  std::get<2>(myarray) = std::get<0>(myarray);
  std::get<0>(myarray) = myelement;

  std::cout << "first element in myarray: " << std::get<0>(myarray) << "\n";
  std::cout << "first element in mytuple: " << std::get<0>(mytuple) << "\n";

  return 0;
}
```

Output

```
first element in myarray: 30
first element in mytuple: 10
```

#### relational operators (array)

å½¢å¦‚ï¼šarrayA != arrayBã€arrayA > arrayBï¼›ä¾æ­¤æ¯”è¾ƒæ•°ç»„æ¯ä¸ªå…ƒç´ çš„å¤§å°å…³ç³»ã€‚

```cpp
ï¼ˆ1ï¼‰	
template <class Tï¼Œsize_T N> 
  bool operator ==ï¼ˆconst array <Tï¼ŒN>ï¼†lhsï¼Œconst array <Tï¼ŒN>ï¼†rhsï¼‰;
ï¼ˆ2ï¼‰	
template <class Tï¼Œsize_T N> 
  bool operatorï¼=ï¼ˆconst array <Tï¼ŒN>ï¼†lhsï¼Œconst array <Tï¼ŒN>ï¼†rhsï¼‰;
ï¼ˆ3ï¼‰	
template <class Tï¼Œsize_T N> 
  bool operator <ï¼ˆconst array <Tï¼ŒN>ï¼†lhsï¼Œconst array <Tï¼ŒN>ï¼†rhsï¼‰;
ï¼ˆ4ï¼‰	
template <class Tï¼Œsize_T N> 
  bool operator <=ï¼ˆconst array <Tï¼ŒN>ï¼†lhsï¼Œconst array <Tï¼ŒN>ï¼†rhsï¼‰;
ï¼ˆ5ï¼‰	
template <class Tï¼Œsize_T N> 
  bool operator>ï¼ˆconst array <Tï¼ŒN>ï¼†lhsï¼Œconst array <Tï¼ŒN>ï¼†rhsï¼‰;
ï¼ˆ6ï¼‰	
template <class Tï¼Œsize_T N> 
  bool operator> =ï¼ˆconst array <Tï¼ŒN>ï¼†lhsï¼Œconst array <Tï¼ŒN>ï¼†rhsï¼‰;
```

Example

```cpp
#include <iostream>
#include <array>

int main ()
{
  std::array<int,5> a = {10, 20, 30, 40, 50};
  std::array<int,5> b = {10, 20, 30, 40, 50};
  std::array<int,5> c = {50, 40, 30, 20, 10};

  if (a==b) std::cout << "a and b are equal\n";
  if (b!=c) std::cout << "b and c are not equal\n";
  if (b<c) std::cout << "b is less than c\n";
  if (c>b) std::cout << "c is greater than b\n";
  if (a<=b) std::cout << "a is less than or equal to b\n";
  if (a>=b) std::cout << "a is greater than or equal to b\n";

  return 0;
}
```

Output

```
a and b are equal
b and c are not equal
b is less than c
c is greater than b
a is less than or equal to b
a is greater than or equal to b
```

### vector

vectoræ˜¯è¡¨ç¤ºå¯ä»¥æ”¹å˜å¤§å°çš„æ•°ç»„çš„åºåˆ—å®¹å™¨ã€‚

å°±åƒæ•°ç»„ä¸€æ ·ï¼Œvectorä¸ºå®ƒä»¬çš„å…ƒç´ ä½¿ç”¨è¿ç»­çš„å­˜å‚¨ä½ç½®ï¼Œè¿™æ„å‘³ç€å®ƒä»¬çš„å…ƒç´ ä¹Ÿå¯ä»¥ä½¿ç”¨åˆ°å…¶å…ƒç´ çš„å¸¸è§„æŒ‡é’ˆä¸Šçš„åç§»æ¥è®¿é—®ï¼Œè€Œä¸”å’Œæ•°ç»„ä¸€æ ·é«˜æ•ˆã€‚ä½†æ˜¯ä¸æ•°ç»„ä¸åŒçš„æ˜¯ï¼Œå®ƒä»¬çš„å¤§å°å¯ä»¥åŠ¨æ€åœ°æ”¹å˜ï¼Œå®ƒä»¬çš„å­˜å‚¨ç”±å®¹å™¨è‡ªåŠ¨å¤„ç†ã€‚

åœ¨å†…éƒ¨ï¼Œvectorä½¿ç”¨ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„æ•°ç»„æ¥å­˜å‚¨å®ƒä»¬çš„å…ƒç´ ã€‚è¿™ä¸ªæ•°ç»„å¯èƒ½éœ€è¦é‡æ–°åˆ†é…ï¼Œä»¥ä¾¿åœ¨æ’å…¥æ–°å…ƒç´ æ—¶å¢åŠ å¤§å°ï¼Œè¿™æ„å‘³ç€åˆ†é…ä¸€ä¸ªæ–°æ•°ç»„å¹¶å°†æ‰€æœ‰å…ƒç´ ç§»åŠ¨åˆ°å…¶ä¸­ã€‚å°±å¤„ç†æ—¶é—´è€Œè¨€ï¼Œè¿™æ˜¯ä¸€ä¸ªç›¸å¯¹æ˜‚è´µçš„ä»»åŠ¡ï¼Œå› æ­¤æ¯æ¬¡å°†å…ƒç´ æ·»åŠ åˆ°å®¹å™¨æ—¶çŸ¢é‡éƒ½ä¸ä¼šé‡æ–°åˆ†é…ã€‚

ç›¸åï¼Œvectorå®¹å™¨å¯ä»¥åˆ†é…ä¸€äº›é¢å¤–çš„å­˜å‚¨ä»¥é€‚åº”å¯èƒ½çš„å¢é•¿ï¼Œå¹¶ä¸”å› æ­¤å®¹å™¨å¯ä»¥å…·æœ‰æ¯”ä¸¥æ ¼éœ€è¦åŒ…å«å…¶å…ƒç´ ï¼ˆå³ï¼Œå…¶å¤§å°ï¼‰çš„å­˜å‚¨æ›´å¤§çš„å®é™…å®¹é‡ã€‚åº“å¯ä»¥å®ç°ä¸åŒçš„ç­–ç•¥çš„å¢é•¿åˆ°å†…å­˜ä½¿ç”¨å’Œé‡æ–°åˆ†é…ä¹‹é—´çš„å¹³è¡¡ï¼Œä½†åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå†åˆ†é…åº”ä»…åœ¨å¯¹æ•°ç”Ÿé•¿çš„é—´éš”å‘ç”Ÿå°ºå¯¸ï¼Œä½¿å¾—åœ¨æ‰€è¿°è½½ä½“çš„æœ«ç«¯å„ä¸ªå…ƒä»¶çš„æ’å…¥å¯ä»¥ä¸æä¾›åˆ†æœŸå¸¸é‡æ—¶é—´å¤æ‚æ€§ã€‚

å› æ­¤ï¼Œä¸æ•°ç»„ç›¸æ¯”ï¼Œè½½ä½“æ¶ˆè€—æ›´å¤šçš„å†…å­˜æ¥äº¤æ¢ç®¡ç†å­˜å‚¨å’Œä»¥æœ‰æ•ˆæ–¹å¼åŠ¨æ€å¢é•¿çš„èƒ½åŠ›ã€‚

ä¸å…¶ä»–åŠ¨æ€åºåˆ—å®¹å™¨ï¼ˆdequesï¼Œlistså’Œ forward\_lists ï¼‰ç›¸æ¯”ï¼Œvectoréå¸¸æœ‰æ•ˆåœ°è®¿é—®å…¶å…ƒç´ ï¼ˆå°±åƒæ•°ç»„ä¸€æ ·ï¼‰ï¼Œå¹¶ç›¸å¯¹æœ‰æ•ˆåœ°ä»å…ƒç´ æœ«å°¾æ·»åŠ æˆ–ç§»é™¤å…ƒç´ ã€‚å¯¹äºæ¶‰åŠæ’å…¥æˆ–ç§»é™¤é™¤äº†ç»“å°¾ä¹‹å¤–çš„ä½ç½®çš„å…ƒç´ çš„æ“ä½œï¼Œå®ƒä»¬æ‰§è¡Œæ¯”å…¶ä»–ä½ç½®æ›´å·®çš„æ“ä½œï¼Œå¹¶ä¸”å…·æœ‰æ¯”åˆ—è¡¨å’Œ forward\_lists æ›´ä¸ä¸€è‡´çš„è¿­ä»£å™¨å’Œå¼•ç”¨ã€‚

é’ˆå¯¹ vector çš„å„ç§å¸¸è§æ“ä½œçš„å¤æ‚åº¦ï¼ˆæ•ˆç‡ï¼‰å¦‚ä¸‹ï¼š 

* éšæœºè®¿é—® - å¸¸æ•° O(1) 
* åœ¨å°¾éƒ¨å¢åˆ å…ƒç´  - å¹³æ‘Šï¼ˆamortizedï¼‰å¸¸æ•° O(1)}} 
* å¢åˆ å…ƒç´  - è‡³ vector å°¾éƒ¨çš„çº¿æ€§è·ç¦» O(n)}}

```cpp
template < class T, class Alloc = allocator<T> > class vector;
```

![](assets/stlæ€»ç»“/20160406151211233)

#### vector::vector

ï¼ˆ1ï¼‰emptyå®¹å™¨æ„é€ å‡½æ•°ï¼ˆé»˜è®¤æ„é€ å‡½æ•°ï¼‰
æ„é€ ä¸€ä¸ªç©ºçš„å®¹å™¨ï¼Œæ²¡æœ‰å…ƒç´ ã€‚
ï¼ˆ2ï¼‰fillæ„é€ å‡½æ•°
ç”¨nä¸ªå…ƒç´ æ„é€ ä¸€ä¸ªå®¹å™¨ã€‚æ¯ä¸ªå…ƒç´ éƒ½æ˜¯valçš„å‰¯æœ¬ï¼ˆå¦‚æœæä¾›ï¼‰ã€‚
ï¼ˆ3ï¼‰èŒƒå›´ï¼ˆrangeï¼‰æ„é€ å™¨
ä½¿ç”¨ä¸[ rangeï¼Œfirstï¼Œlast]èŒƒå›´å†…çš„å…ƒç´ ç›¸åŒçš„é¡ºåºæ„é€ ä¸€ä¸ªå®¹å™¨ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯emplace -ä»è¯¥èŒƒå›´å†…ç›¸åº”çš„å…ƒç´ æ„é€ è€Œæˆã€‚
ï¼ˆ4ï¼‰å¤åˆ¶ï¼ˆcopyï¼‰æ„é€ å‡½æ•°ï¼ˆå¹¶ç”¨åˆ†é…å™¨å¤åˆ¶ï¼‰
æŒ‰ç…§ç›¸åŒçš„é¡ºåºæ„é€ ä¸€ä¸ªåŒ…å«xä¸­æ¯ä¸ªå…ƒç´ çš„å‰¯æœ¬çš„å®¹å™¨ã€‚
ï¼ˆ5ï¼‰ç§»åŠ¨ï¼ˆmoveï¼‰æ„é€ å‡½æ•°ï¼ˆå’Œåˆ†é…å™¨ç§»åŠ¨ï¼‰
æ„é€ ä¸€ä¸ªè·å–xå…ƒç´ çš„å®¹å™¨ã€‚
å¦‚æœæŒ‡å®šäº†allocå¹¶ä¸”ä¸xçš„åˆ†é…å™¨ä¸åŒï¼Œé‚£ä¹ˆå…ƒç´ å°†è¢«ç§»åŠ¨ã€‚å¦åˆ™ï¼Œæ²¡æœ‰æ„å»ºå…ƒç´ ï¼ˆä»–ä»¬çš„æ‰€æœ‰æƒç›´æ¥è½¬ç§»ï¼‰ã€‚
xä¿æŒæœªæŒ‡å®šä½†æœ‰æ•ˆçš„çŠ¶æ€ã€‚
ï¼ˆ6ï¼‰åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°
æ„é€ ä¸€ä¸ªå®¹å™¨ä¸­çš„æ¯ä¸ªå…ƒä»¶ä¸­çš„ä¸€ä¸ªæ‹·è´çš„ILï¼Œä»¥ç›¸åŒçš„é¡ºåºã€‚

```cpp
default (1)	
explicit vector (const allocator_type& alloc = allocator_type());
fill (2)	
explicit vector (size_type n);
         vector (size_type n, const value_type& val,
                 const allocator_type& alloc = allocator_type());
range (3)	
template <class InputIterator>
  vector (InputIterator first, InputIterator last,
          const allocator_type& alloc = allocator_type());
copy (4)	
vector (const vector& x);
vector (const vector& x, const allocator_type& alloc);
move (5)	
vector (vector&& x);
vector (vector&& x, const allocator_type& alloc);
initializer list (6)	
vector (initializer_list<value_type> il,
       const allocator_type& alloc = allocator_type());
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
    // constructors used in the same order as described above:
    std::vector<int> first;             // empty vector of ints
    std::vector<int> second(4, 100);    // four ints with value 100
    std::vector<int> third(second.begin(), second.end());// iterating through second
    std::vector<int> fourth(third);     // a copy of third

    // the iterator constructor can also be used to construct from arrays:
    int myints[] = {16,2,77,29};
    std::vector<int> fifth(myints, myints + sizeof(myints) / sizeof(int));

    std::cout << "The contents of fifth are:";
    for(std::vector<int>::iterator it = fifth.begin(); it != fifth.end(); ++it)
        std::cout << ' ' << *it;
    std::cout << '\n';

    return 0;
}
```

Output

```
The contents of fifth are: 16 2 77 29 
```

#### vector::~vector

é”€æ¯å®¹å™¨å¯¹è±¡ã€‚è¿™å°†åœ¨æ¯ä¸ªåŒ…å«çš„å…ƒç´ ä¸Šè°ƒç”¨allocator_traits::destroyï¼Œå¹¶ä½¿ç”¨å…¶åˆ†é…å™¨é‡Šæ”¾ç”±çŸ¢é‡åˆ†é…çš„æ‰€æœ‰å­˜å‚¨å®¹é‡ã€‚

```cpp
~vector();
```

#### vector::operator=

å°†æ–°å†…å®¹åˆ†é…ç»™å®¹å™¨ï¼Œæ›¿æ¢å…¶å½“å‰å†…å®¹ï¼Œå¹¶ç›¸åº”åœ°ä¿®æ”¹å…¶å¤§å°ã€‚

```cpp
copy (1)	
vector& operator= (const vector& x);
move (2)	
vector& operator= (vector&& x);
initializer list (3)	
vector& operator= (initializer_list<value_type> il);
```

Example

```
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> foo (3,0);
  std::vector<int> bar (5,0);

  bar = foo;
  foo = std::vector<int>();

  std::cout << "Size of foo: " << int(foo.size()) << '\n';
  std::cout << "Size of bar: " << int(bar.size()) << '\n';
  return 0;
}
```

Output

```
Size of foo: 0
Size of bar: 3
```

#### vector::begin

#### vector::end

#### vector::rbegin

#### vector::rend

#### vector::cbegin

#### vector::cend

#### vector::rcbegin

#### vector::rcend

#### vector::size

è¿”å›vectorä¸­å…ƒç´ çš„æ•°é‡ã€‚

è¿™æ˜¯vectorä¸­ä¿å­˜çš„å®é™…å¯¹è±¡çš„æ•°é‡ï¼Œä¸ä¸€å®šç­‰äºå…¶å­˜å‚¨å®¹é‡ã€‚

```cpp
size_type size() const noexcept;
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myints;
  std::cout << "0. size: " << myints.size() << '\n';

  for (int i=0; i<10; i++) myints.push_back(i);
  std::cout << "1. size: " << myints.size() << '\n';

  myints.insert (myints.end(),10,100);
  std::cout << "2. size: " << myints.size() << '\n';

  myints.pop_back();
  std::cout << "3. size: " << myints.size() << '\n';

  return 0;
}
```

Output

```
0. size: 0
1. size: 10
2. size: 20
3. size: 19
```

#### vector::max_size

è¿”å›è¯¥vectorå¯å®¹çº³çš„å…ƒç´ çš„æœ€å¤§æ•°é‡ã€‚ç”±äºå·²çŸ¥çš„ç³»ç»Ÿæˆ–åº“å®ç°é™åˆ¶ï¼Œ

è¿™æ˜¯å®¹å™¨å¯ä»¥è¾¾åˆ°çš„æœ€å¤§æ½œåœ¨å¤§å°ï¼Œä½†å®¹å™¨æ— æ³•ä¿è¯èƒ½å¤Ÿè¾¾åˆ°è¯¥å¤§å°ï¼šåœ¨è¾¾åˆ°è¯¥å¤§å°ä¹‹å‰çš„ä»»ä½•æ—¶é—´ï¼Œä»ç„¶æ— æ³•åˆ†é…å­˜å‚¨ã€‚

```cpp
size_type max_size() const noexcept;
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;

  // set some content in the vector:
  for (int i=0; i<100; i++) myvector.push_back(i);

  std::cout << "size: " << myvector.size() << "\n";
  std::cout << "capacity: " << myvector.capacity() << "\n";
  std::cout << "max_size: " << myvector.max_size() << "\n";
  return 0;
}
```

A possible output for this program could be:

```
size: 100
capacity: 128
max_size: 1073741823
```

#### vector::resize

è°ƒæ•´å®¹å™¨çš„å¤§å°ï¼Œä½¿å…¶åŒ…å«nä¸ªå…ƒç´ ã€‚

å¦‚æœnå°äºå½“å‰çš„å®¹å™¨sizeï¼Œå†…å®¹å°†è¢«ç¼©å°åˆ°å‰nä¸ªå…ƒç´ ï¼Œå°†å…¶åˆ é™¤ï¼ˆå¹¶é”€æ¯å®ƒä»¬ï¼‰ã€‚

å¦‚æœnå¤§äºå½“å‰å®¹å™¨sizeï¼Œåˆ™é€šè¿‡åœ¨æœ«å°¾æ’å…¥å°½å¯èƒ½å¤šçš„å…ƒç´ ä»¥è¾¾åˆ°å¤§å°næ¥æ‰©å±•å†…å®¹ã€‚å¦‚æœæŒ‡å®šäº†valï¼Œåˆ™æ–°å…ƒç´ å°†åˆå§‹åŒ–ä¸ºvalçš„å‰¯æœ¬ï¼Œå¦åˆ™å°†è¿›è¡Œå€¼åˆå§‹åŒ–ã€‚

å¦‚æœnä¹Ÿå¤§äºå½“å‰çš„å®¹å™¨çš„capacityï¼ˆå®¹é‡ï¼‰ï¼Œåˆ†é…çš„å­˜å‚¨ç©ºé—´å°†è‡ªåŠ¨é‡æ–°åˆ†é…ã€‚

æ³¨æ„è¿™ä¸ªå‡½æ•°é€šè¿‡æ’å…¥æˆ–è€…åˆ é™¤å…ƒç´ çš„å†…å®¹æ¥æ”¹å˜å®¹å™¨çš„å®é™…å†…å®¹ã€‚

```cpp
void resize (size_type n);
void resize (size_type n, const value_type& val);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;

  // set some initial content:
  for (int i=1;i<10;i++) myvector.push_back(i);

  myvector.resize(5);
  myvector.resize(8,100);
  myvector.resize(12);

  std::cout << "myvector contains:";
  for (int i=0;i<myvector.size();i++)
    std::cout << ' ' << myvector[i];
  std::cout << '\n';

  return 0;
}
```

Output

```
myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0
```

#### vector::capacity

è¿”å›å½“å‰ä¸ºvectoråˆ†é…çš„å­˜å‚¨ç©ºé—´çš„å¤§å°ï¼Œç”¨å…ƒç´ è¡¨ç¤ºã€‚è¿™ä¸ªcapacity(å®¹é‡)ä¸ä¸€å®šç­‰äºvectorçš„sizeã€‚å®ƒå¯ä»¥ç›¸ç­‰æˆ–æ›´å¤§ï¼Œé¢å¤–çš„ç©ºé—´å…è®¸é€‚åº”å¢é•¿ï¼Œè€Œä¸éœ€è¦é‡æ–°åˆ†é…æ¯ä¸ªæ’å…¥ã€‚

```cpp
size_type capacity() const noexcept;
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;

  // set some content in the vector:
  for (int i=0; i<100; i++) myvector.push_back(i);

  std::cout << "size: " << (int) myvector.size() << '\n';
  std::cout << "capacity: " << (int) myvector.capacity() << '\n';
  std::cout << "max_size: " << (int) myvector.max_size() << '\n';
  return 0;
}
```

A possible output for this program could be:

```
size: 100
capacity: 128
max_size: 1073741823
```

#### vector::empty

è¿”å›vectoræ˜¯å¦ä¸ºç©ºï¼ˆå³ï¼Œå®ƒçš„sizeæ˜¯å¦ä¸º0ï¼‰

```cpp
bool empty() const noexcept;
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;
  int sum (0);

  for (int i=1;i<=10;i++) myvector.push_back(i);

  while (!myvector.empty())
  {
     sum += myvector.back();
     myvector.pop_back();
  }

  std::cout << "total: " << sum << '\n';

  return 0;
}
```

Output

```
total: 55
```

#### vector::reserve

è¯·æ±‚vectorå®¹é‡è‡³å°‘è¶³ä»¥åŒ…å«nä¸ªå…ƒç´ ã€‚

å¦‚æœnå¤§äºå½“å‰vectorå®¹é‡ï¼Œåˆ™è¯¥å‡½æ•°ä½¿å®¹å™¨é‡æ–°åˆ†é…å…¶å­˜å‚¨å®¹é‡ï¼Œä»è€Œå°†å…¶å®¹é‡å¢åŠ åˆ°nï¼ˆæˆ–æ›´å¤§ï¼‰ã€‚

åœ¨æ‰€æœ‰å…¶ä»–æƒ…å†µä¸‹ï¼Œå‡½æ•°è°ƒç”¨ä¸ä¼šå¯¼è‡´é‡æ–°åˆ†é…ï¼Œå¹¶ä¸”vectorå®¹é‡ä¸å—å½±å“ã€‚

è¿™ä¸ªå‡½æ•°å¯¹vectorå¤§å°æ²¡æœ‰å½±å“ï¼Œä¹Ÿä¸èƒ½æ”¹å˜å®ƒçš„å…ƒç´ ã€‚

```cpp
void reserve (size_type n);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int>::size_type sz;

  std::vector<int> foo;
  sz = foo.capacity();
  std::cout << "making foo grow:\n";
  for (int i=0; i<100; ++i) {
    foo.push_back(i);
    if (sz!=foo.capacity()) {
      sz = foo.capacity();
      std::cout << "capacity changed: " << sz << '\n';
    }
  }

  std::vector<int> bar;
  sz = bar.capacity();
  bar.reserve(100);   // this is the only difference with foo above
  std::cout << "making bar grow:\n";
  for (int i=0; i<100; ++i) {
    bar.push_back(i);
    if (sz!=bar.capacity()) {
      sz = bar.capacity();
      std::cout << "capacity changed: " << sz << '\n';
    }
  }
  return 0;
}
```

Possible output

```
making foo grow:
capacity changed: 1
capacity changed: 2
capacity changed: 4
capacity changed: 8
capacity changed: 16
capacity changed: 32
capacity changed: 64
capacity changed: 128
making bar grow:
capacity changed: 100
```

#### vector::shrink_to_fit

è¦æ±‚å®¹å™¨å‡å°å…¶capacity(å®¹é‡)ä»¥é€‚åº”å…¶å°ºå¯¸ã€‚

è¯¥è¯·æ±‚æ˜¯éç»‘å®šçš„ï¼Œå¹¶ä¸”å®¹å™¨å®ç°å¯ä»¥è‡ªç”±åœ°è¿›è¡Œä¼˜åŒ–ï¼Œå¹¶ä¸”ä¿æŒcapacityå¤§äºå…¶sizeçš„vectorã€‚ è¿™å¯èƒ½å¯¼è‡´é‡æ–°åˆ†é…ï¼Œä½†å¯¹çŸ¢é‡å¤§å°æ²¡æœ‰å½±å“ï¼Œå¹¶ä¸”ä¸èƒ½æ”¹å˜å…¶å…ƒç´ ã€‚

```cpp
void shrink_to_fit();
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector (100);
  std::cout << "1. capacity of myvector: " << myvector.capacity() << '\n';

  myvector.resize(10);
  std::cout << "2. capacity of myvector: " << myvector.capacity() << '\n';

  myvector.shrink_to_fit();
  std::cout << "3. capacity of myvector: " << myvector.capacity() << '\n';

  return 0;
}
```

Possible output

```
1. capacity of myvector: 100
2. capacity of myvector: 100
3. capacity of myvector: 10
```

#### vector::operator[]

#### vector::at

#### vector::front

#### vector::back

#### vector::data

#### vector::assign

å°†æ–°å†…å®¹åˆ†é…ç»™vectorï¼Œæ›¿æ¢å…¶å½“å‰å†…å®¹ï¼Œå¹¶ç›¸åº”åœ°ä¿®æ”¹å…¶å¤§å°ã€‚

åœ¨èŒƒå›´ç‰ˆæœ¬ï¼ˆ1ï¼‰ä¸­ï¼Œæ–°å†…å®¹æ˜¯ä»ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªèŒƒå›´å†…çš„æ¯ä¸ªå…ƒç´ æŒ‰ç›¸åŒé¡ºåºæ„é€ çš„å…ƒç´ ã€‚

åœ¨å¡«å……ç‰ˆæœ¬ï¼ˆ2ï¼‰ä¸­ï¼Œæ–°å†…å®¹æ˜¯nä¸ªå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ éƒ½è¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªvalçš„å‰¯æœ¬ã€‚

åœ¨åˆå§‹åŒ–åˆ—è¡¨ç‰ˆæœ¬ï¼ˆ3ï¼‰ä¸­ï¼Œæ–°å†…å®¹æ˜¯ä»¥ç›¸åŒé¡ºåºä½œä¸ºåˆå§‹åŒ–åˆ—è¡¨ä¼ é€’çš„å€¼çš„å‰¯æœ¬ã€‚

æ‰€è¿°å†…éƒ¨åˆ†é…å™¨è¢«ç”¨äºï¼ˆé€šè¿‡å…¶æ€§çŠ¶ï¼‰ï¼Œä»¥åˆ†é…å’Œè§£é™¤åˆ†é…å­˜å‚¨å™¨å¦‚æœé‡æ–°åˆ†é…å‘ç”Ÿã€‚å®ƒä¹Ÿä¹ æƒ¯äºæ‘§æ¯æ‰€æœ‰ç°æœ‰çš„å…ƒç´ ï¼Œå¹¶æ„å»ºæ–°çš„å…ƒç´ ã€‚

```cpp
range (1)	
template <class InputIterator>
  void assign (InputIterator first, InputIterator last);
fill (2)	
void assign (size_type n, const value_type& val);
initializer list (3)	
void assign (initializer_list<value_type> il);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> first;
  std::vector<int> second;
  std::vector<int> third;

  first.assign (7,100);             // 7 ints with a value of 100

  std::vector<int>::iterator it;
  it=first.begin()+1;

  second.assign (it,first.end()-1); // the 5 central values of first

  int myints[] = {1776,7,4};
  third.assign (myints,myints+3);   // assigning from array.

  std::cout << "Size of first: " << int (first.size()) << '\n';
  std::cout << "Size of second: " << int (second.size()) << '\n';
  std::cout << "Size of third: " << int (third.size()) << '\n';
  return 0;
}
```

Output

```
Size of first: 7
Size of second: 5
Size of third: 3
```

è¡¥å……ï¼švector::assign ä¸ vector::operator= çš„åŒºåˆ«ï¼š

1. vector::assign å®ç°æºç 

```cpp
void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val) 
{
  if (__n > capacity()) {
    vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());
    __tmp.swap(*this);
  }
  else if (__n > size()) {
    fill(begin(), end(), __val);
    _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);
  }
  else
    erase(fill_n(begin(), __n, __val), end());
}
```

2. vector::operator= å®ç°æºç 

```cpp
template <class _Tp, class _Alloc>
vector<_Tp,_Alloc>& 
vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)
{
  if (&__x != this) {
    const size_type __xlen = __x.size();
    if (__xlen > capacity()) {
      iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
      destroy(_M_start, _M_finish);
      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
      _M_start = __tmp;
      _M_end_of_storage = _M_start + __xlen;
    }
    else if (size() >= __xlen) {
      iterator __i = copy(__x.begin(), __x.end(), begin());
      destroy(__i, _M_finish);
    }
    else {
      copy(__x.begin(), __x.begin() + size(), _M_start);
      uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);
    }
    _M_finish = _M_start + __xlen;
  }
  return *this;
}
```

#### vector::push_back

åœ¨vectorçš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åæ·»åŠ ä¸€ä¸ªæ–°å…ƒç´ ã€‚valçš„å†…å®¹è¢«å¤åˆ¶ï¼ˆæˆ–ç§»åŠ¨ï¼‰åˆ°æ–°çš„å…ƒç´ ã€‚

è¿™æœ‰æ•ˆåœ°å°†å®¹å™¨sizeå¢åŠ äº†ä¸€ä¸ªï¼Œå¦‚æœæ–°çš„çŸ¢é‡sizeè¶…è¿‡äº†å½“å‰vectorçš„capacityï¼Œåˆ™å¯¼è‡´æ‰€åˆ†é…çš„å­˜å‚¨ç©ºé—´è‡ªåŠ¨é‡æ–°åˆ†é…ã€‚

```cpp
void push_back (const value_type& val);
void push_back (value_type&& val);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;
  int myint;

  std::cout << "Please enter some integers (enter 0 to end):\n";

  do {
    std::cin >> myint;
    myvector.push_back (myint);
  } while (myint);

  std::cout << "myvector stores " << int(myvector.size()) << " numbers.\n";

  return 0;
}
```

#### vector::pop_back

åˆ é™¤vectorä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæœ‰æ•ˆåœ°å°†å®¹å™¨sizeå‡å°‘ä¸€ä¸ªã€‚

è¿™ç ´åäº†è¢«åˆ é™¤çš„å…ƒç´ ã€‚

```cpp
void pop_back();
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;
  int sum (0);
  myvector.push_back (100);
  myvector.push_back (200);
  myvector.push_back (300);

  while (!myvector.empty())
  {
    sum+=myvector.back();
    myvector.pop_back();
  }

  std::cout << "The elements of myvector add up to " << sum << '\n';

  return 0;
}
```

Output

```
The elements of myvector add up to 600
```

#### vector::insert

é€šè¿‡åœ¨æŒ‡å®šä½ç½®çš„å…ƒç´ ä¹‹å‰æ’å…¥æ–°å…ƒç´ æ¥æ‰©å±•è¯¥vectorï¼Œé€šè¿‡æ’å…¥å…ƒç´ çš„æ•°é‡æœ‰æ•ˆåœ°å¢åŠ å®¹å™¨å¤§å°ã€‚ è¿™ä¼šå¯¼è‡´åˆ†é…çš„å­˜å‚¨ç©ºé—´è‡ªåŠ¨é‡æ–°åˆ†é…ï¼Œåªæœ‰åœ¨æ–°çš„vectorçš„sizeè¶…è¿‡å½“å‰çš„vectorçš„capacityçš„æƒ…å†µä¸‹ã€‚ 

ç”±äºvectorä½¿ç”¨æ•°ç»„ä½œä¸ºå…¶åŸºç¡€å­˜å‚¨ï¼Œå› æ­¤é™¤äº†å°†å…ƒç´ æ’å…¥åˆ°vectoræœ«å°¾ä¹‹åï¼Œæˆ–vectorçš„beginä¹‹å‰ï¼Œå…¶ä»–ä½ç½®ä¼šå¯¼è‡´å®¹å™¨é‡æ–°å®šä½ä½ç½®ä¹‹åçš„æ‰€æœ‰å…ƒç´ åˆ°ä»–ä»¬çš„æ–°ä½ç½®ã€‚ä¸å…¶ä»–ç§ç±»çš„åºåˆ—å®¹å™¨ï¼ˆä¾‹å¦‚listæˆ–forward_listï¼‰æ‰§è¡Œç›¸åŒæ“ä½œçš„æ“ä½œç›¸æ¯”ï¼Œè¿™é€šå¸¸æ˜¯ä½æ•ˆçš„æ“ä½œã€‚

```cpp
single element (1)	
iterator insert (const_iterator position, const value_type& val);
fill (2)	
iterator insert (const_iterator position, size_type n, const value_type& val);
range (3)	
template <class InputIterator>
iterator insert (const_iterator position, InputIterator first, InputIterator last);
move (4)	
iterator insert (const_iterator position, value_type&& val);
initializer list (5)	
iterator insert (const_iterator position, initializer_list<value_type> il);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector (3,100);
  std::vector<int>::iterator it;

  it = myvector.begin();
  it = myvector.insert ( it , 200 );

  myvector.insert (it,2,300);

  // "it" no longer valid, get a new one:
  it = myvector.begin();

  std::vector<int> anothervector (2,400);
  myvector.insert (it+2,anothervector.begin(),anothervector.end());

  int myarray [] = { 501,502,503 };
  myvector.insert (myvector.begin(), myarray, myarray+3);

  std::cout << "myvector contains:";
  for (it=myvector.begin(); it<myvector.end(); it++)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
```

Output

```
myvector contains: 501 502 503 300 300 400 400 200 100 100 100
```

è¡¥å……ï¼šinsert è¿­ä»£å™¨é‡æŒ‡é’ˆé”™è¯¯ï¼š

```cpp
int main()
{
	std::vector<int> v(5, 0);
	std::vector<int>::iterator vi;

  // è·å–vectorç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨
	vi = v.begin();

  // push_back æ’å…¥å…ƒç´ ä¹‹åå¯èƒ½ä¼šå› ä¸º push_back çš„éªšæ“ä½œï¼ˆåˆ›å»ºä¸€ä¸ªæ–°vectoræŠŠæ—§vectorçš„å€¼å¤åˆ¶åˆ°æ–°vectorï¼‰ï¼Œå¯¼è‡´vectorè¿­ä»£å™¨iteratorçš„æŒ‡é’ˆå˜æˆé‡æŒ‡é’ˆï¼Œè€Œå¯¼è‡´insertå‡ºé”™
	v.push_back(10);

	v.insert(vi, 2, 300);

	return 0;
}
```

æ”¹æ­£ï¼šåº”è¯¥æŠŠ`vi = v.begin();`æ”¾åˆ°`v.push_back(10);`åé¢

#### vector::erase

ä»vectorä¸­åˆ é™¤å•ä¸ªå…ƒç´ ï¼ˆpositionï¼‰æˆ–ä¸€ç³»åˆ—å…ƒç´ ï¼ˆ[firstï¼Œlastï¼‰ï¼‰ã€‚

è¿™æœ‰æ•ˆåœ°å‡å°‘äº†è¢«å»é™¤çš„å…ƒç´ çš„æ•°é‡ï¼Œä»è€Œç ´åäº†å®¹å™¨çš„å¤§å°ã€‚

ç”±äºvectorä½¿ç”¨ä¸€ä¸ªæ•°ç»„ä½œä¸ºå…¶åº•å±‚å­˜å‚¨ï¼Œæ‰€ä»¥åˆ é™¤é™¤vectorç»“æŸä½ç½®ä¹‹åï¼Œæˆ–vectorçš„beginä¹‹å‰çš„å…ƒç´ å¤–ï¼Œå°†å¯¼è‡´å®¹å™¨å°†æ®µè¢«æ“¦é™¤åçš„æ‰€æœ‰å…ƒç´ é‡æ–°å®šä½åˆ°æ–°çš„ä½ç½®ã€‚ä¸å…¶ä»–ç§ç±»çš„åºåˆ—å®¹å™¨ï¼ˆä¾‹å¦‚listæˆ–forward_listï¼‰æ‰§è¡Œç›¸åŒæ“ä½œçš„æ“ä½œç›¸æ¯”ï¼Œè¿™é€šå¸¸æ˜¯ä½æ•ˆçš„æ“ä½œã€‚

```cpp
iterator erase (const_iterator position);
iterator erase (const_iterator first, const_iterator last);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;

  // set some values (from 1 to 10)
  for (int i=1; i<=10; i++) myvector.push_back(i);

  // erase the 6th element
  myvector.erase (myvector.begin()+5);

  // erase the first 3 elements:
  myvector.erase (myvector.begin(),myvector.begin()+3);

  std::cout << "myvector contains:";
  for (unsigned i=0; i<myvector.size(); ++i)
    std::cout << ' ' << myvector[i];
  std::cout << '\n';

  return 0;
}
```

Output

```
myvector contains: 4 5 7 8 9 10
```

#### vector::swap

é€šè¿‡xçš„å†…å®¹äº¤æ¢å®¹å™¨çš„å†…å®¹ï¼Œxæ˜¯å¦ä¸€ä¸ªç›¸åŒç±»å‹çš„vectorå¯¹è±¡ã€‚å°ºå¯¸å¯èƒ½ä¸åŒã€‚

åœ¨è°ƒç”¨è¿™ä¸ªæˆå‘˜å‡½æ•°ä¹‹åï¼Œè¿™ä¸ªå®¹å™¨ä¸­çš„å…ƒç´ æ˜¯é‚£äº›åœ¨è°ƒç”¨ä¹‹å‰åœ¨xä¸­çš„å…ƒç´ ï¼Œè€Œxçš„å…ƒç´ æ˜¯åœ¨è¿™ä¸ªå…ƒç´ ä¸­çš„å…ƒç´ ã€‚æ‰€æœ‰è¿­ä»£å™¨ï¼Œå¼•ç”¨å’ŒæŒ‡é’ˆå¯¹äº¤æ¢å¯¹è±¡ä¿æŒæœ‰æ•ˆã€‚

è¯·æ³¨æ„ï¼Œéæˆå‘˜å‡½æ•°å­˜åœ¨å…·æœ‰ç›¸åŒåç§°çš„äº¤æ¢ï¼Œå¹¶ä½¿ç”¨ä¸æ­¤æˆå‘˜å‡½æ•°ç›¸ä¼¼çš„ä¼˜åŒ–æ¥é‡è½½è¯¥ç®—æ³•ã€‚

```cpp
void swap (vector& x);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> foo (3,100);   // three ints with a value of 100
  std::vector<int> bar (5,200);   // five ints with a value of 200

  foo.swap(bar);

  std::cout << "foo contains:";
  for (unsigned i=0; i<foo.size(); i++)
    std::cout << ' ' << foo[i];
  std::cout << '\n';

  std::cout << "bar contains:";
  for (unsigned i=0; i<bar.size(); i++)
    std::cout << ' ' << bar[i];
  std::cout << '\n';

  return 0;
}
```

Output

```
foo contains: 200 200 200 200 200 
bar contains: 100 100 100 
```

#### vector::clear

ä»vectorä¸­åˆ é™¤æ‰€æœ‰çš„å…ƒç´ ï¼ˆè¢«é”€æ¯ï¼‰ï¼Œç•™ä¸‹sizeä¸º0çš„å®¹å™¨ã€‚

ä¸ä¿è¯é‡æ–°åˆ†é…ï¼Œå¹¶ä¸”ç”±äºè°ƒç”¨æ­¤å‡½æ•°ï¼Œ vectorçš„capacityä¸ä¿è¯å‘ç”Ÿå˜åŒ–ã€‚å¼ºåˆ¶é‡æ–°åˆ†é…çš„å…¸å‹æ›¿ä»£æ–¹æ³•æ˜¯ä½¿ç”¨swapï¼š`vector<T>().swap(x);   // clear x reallocating `

```cpp
void clear() noexcept;
```

Example

```cpp
#include <iostream>
#include <vector>

void printVector(const std::vector<int> &v)
{
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		std::cout << *it << ' ';
	}
	std::cout << std::endl;
}

int main()
{
	std::vector<int> v1(5, 50);

	printVector(v1);
	std::cout << "v1 size  = " << v1.size() << std::endl;
	std::cout << "v1 capacity  = " << v1.capacity() << std::endl;

	v1.clear();

	printVector(v1);
	std::cout << "v1 size  = " << v1.size() << std::endl;
	std::cout << "v1 capacity  = " << v1.capacity() << std::endl;

	v1.push_back(11);
	v1.push_back(22);

	printVector(v1);
	std::cout << "v1 size  = " << v1.size() << std::endl;
	std::cout << "v1 capacity  = " << v1.capacity() << std::endl;

	return 0;
}
```

Output

```
50 50 50 50 50
v1 size  = 5
v1 capacity  = 5

v1 size  = 0
v1 capacity  = 5
11 22
v1 size  = 2
v1 capacity  = 5
```

#### vector::emplace

é€šè¿‡åœ¨positionä½ç½®å¤„æ’å…¥æ–°å…ƒç´ argsæ¥æ‰©å±•å®¹å™¨ã€‚è¿™ä¸ªæ–°å…ƒç´ æ˜¯ç”¨argsä½œä¸ºæ„å»ºçš„å‚æ•°æ¥æ„å»ºçš„ã€‚

è¿™æœ‰æ•ˆåœ°å¢åŠ äº†ä¸€ä¸ªå®¹å™¨çš„å¤§å°ã€‚

åˆ†é…å­˜å‚¨ç©ºé—´çš„è‡ªåŠ¨é‡æ–°åˆ†é…å‘ç”Ÿåœ¨æ–°çš„vectorçš„sizeè¶…è¿‡å½“å‰å‘é‡å®¹é‡çš„æƒ…å†µä¸‹ã€‚

ç”±äºvectorä½¿ç”¨æ•°ç»„ä½œä¸ºå…¶åŸºç¡€å­˜å‚¨ï¼Œå› æ­¤é™¤äº†å°†å…ƒç´ æ’å…¥åˆ°vectoræœ«å°¾ä¹‹åï¼Œæˆ–vectorçš„beginä¹‹å‰ï¼Œå…¶ä»–ä½ç½®ä¼šå¯¼è‡´å®¹å™¨é‡æ–°å®šä½ä½ç½®ä¹‹åçš„æ‰€æœ‰å…ƒç´ åˆ°ä»–ä»¬çš„æ–°ä½ç½®ã€‚ä¸å…¶ä»–ç§ç±»çš„åºåˆ—å®¹å™¨ï¼ˆä¾‹å¦‚listæˆ–forward_listï¼‰æ‰§è¡Œç›¸åŒæ“ä½œçš„æ“ä½œç›¸æ¯”ï¼Œè¿™é€šå¸¸æ˜¯ä½æ•ˆçš„æ“ä½œã€‚

è¯¥å…ƒç´ æ˜¯é€šè¿‡è°ƒç”¨allocator_traits::constructæ¥è½¬æ¢argsæ¥åˆ›å»ºçš„ã€‚æ’å…¥ä¸€ä¸ªç±»ä¼¼çš„æˆå‘˜å‡½æ•°ï¼Œå°†ç°æœ‰å¯¹è±¡å¤åˆ¶æˆ–ç§»åŠ¨åˆ°å®¹å™¨ä¸­ã€‚

```cpp
template <class... Args>
iterator emplace (const_iterator position, Args&&... args);
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector = {10,20,30};

  auto it = myvector.emplace ( myvector.begin()+1, 100 );
  myvector.emplace ( it, 200 );
  myvector.emplace ( myvector.end(), 300 );

  std::cout << "myvector contains:";
  for (auto& x: myvector)
    std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```

Output

```
myvector contains: 10 200 100 20 30 300
```

#### vector::emplace_back

åœ¨vectorçš„æœ«å°¾æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œç´§è·Ÿåœ¨å½“å‰çš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åã€‚è¿™ä¸ªæ–°å…ƒç´ æ˜¯ç”¨argsä½œä¸ºæ„é€ å‡½æ•°çš„å‚æ•°æ¥æ„é€ çš„ã€‚

è¿™æœ‰æ•ˆåœ°å°†å®¹å™¨å¤§å°å¢åŠ äº†ä¸€ä¸ªï¼Œå¦‚æœæ–°çš„çŸ¢é‡å¤§å°è¶…è¿‡äº†å½“å‰çš„vectorå®¹é‡ï¼Œåˆ™å¯¼è‡´æ‰€åˆ†é…çš„å­˜å‚¨ç©ºé—´è‡ªåŠ¨é‡æ–°åˆ†é…ã€‚

è¯¥å…ƒç´ æ˜¯é€šè¿‡è°ƒç”¨allocator_traits :: constructæ¥è½¬æ¢argsæ¥åˆ›å»ºçš„ã€‚

ä¸push\_backç›¸æ¯”ï¼Œemplace\_backå¯ä»¥é¿å…é¢å¤–çš„å¤åˆ¶å’Œç§»åŠ¨æ“ä½œã€‚

```cpp
template <class... Args>
  void emplace_back (Args&&... args);
```

Example

```cpp
#include <vector>
#include <string>
#include <iostream>
 
struct President
{
    std::string name;
    std::string country;
    int year;
 
    President(std::string p_name, std::string p_country, int p_year)
        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)
    {
        std::cout << "I am being constructed.\n";
    }
    President(President&& other)
        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)
    {
        std::cout << "I am being moved.\n";
    }
    President& operator=(const President& other) = default;
};
 
int main()
{
    std::vector<President> elections;
    std::cout << "emplace_back:\n";
    elections.emplace_back("Nelson Mandela", "South Africa", 1994);
 
    std::vector<President> reElections;
    std::cout << "\npush_back:\n";
    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));
 
    std::cout << "\nContents:\n";
    for (President const& president: elections) {
        std::cout << president.name << " was elected president of "
                  << president.country << " in " << president.year << ".\n";
    }
    for (President const& president: reElections) {
        std::cout << president.name << " was re-elected president of "
                  << president.country << " in " << president.year << ".\n";
    }
}
```

Output

```
emplace_back:
I am being constructed.
 
push_back:
I am being constructed.
I am being moved.
 
Contents:
Nelson Mandela was elected president of South Africa in 1994.
Franklin Delano Roosevelt was re-elected president of the USA in 1936.
```

#### vector::get_allocator

è¿”å›ä¸vectorå…³è”çš„æ„é€ å™¨å¯¹è±¡çš„å‰¯æœ¬ã€‚

```cpp
allocator_type get_allocator() const noexcept;
```

Example

```cpp
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;
  int * p;
  unsigned int i;

  // allocate an array with space for 5 elements using vector's allocator:
  p = myvector.get_allocator().allocate(5);

  // construct values in-place on the array:
  for (i=0; i<5; i++) myvector.get_allocator().construct(&p[i],i);

  std::cout << "The allocated array contains:";
  for (i=0; i<5; i++) std::cout << ' ' << p[i];
  std::cout << '\n';

  // destroy and deallocate:
  for (i=0; i<5; i++) myvector.get_allocator().destroy(&p[i]);
  myvector.get_allocator().deallocate(p,5);

  return 0;
}
```

Output

```
The allocated array contains: 0 1 2 3 4
```

æ³¨æ„ï¼šdeallocateå’Œdestoryçš„å…³ç³»ï¼š

deallocateå®ç°çš„æºç ï¼š

	template <class T>
	inline void _deallocate(T* buffer)
	{
		::operator delete(buffer);    //ä¸ºä»€ä¹ˆä¸ç”¨ delete [] ?  ,operator delete åŒºåˆ«äº delete 
		                             //operator delete  æ˜¯ä¸€ä¸ªåº•å±‚æ“ä½œç¬¦
	}

destoryï¼š

	template <class T>
	inline void _destory(T *ptr)
	{
		ptr->~T();
	}

destoryè´Ÿè´£è°ƒç”¨ç±»å‹çš„ææ„å‡½æ•°ï¼Œé”€æ¯ç›¸åº”å†…å­˜ä¸Šçš„å†…å®¹ï¼ˆä½†é”€æ¯åå†…å­˜åœ°å€ä»ä¿ç•™ï¼‰

deallocateè´Ÿè´£é‡Šæ”¾å†…å­˜ï¼ˆæ­¤æ—¶ç›¸åº”å†…å­˜ä¸­çš„å€¼åœ¨æ­¤ä¹‹å‰åº”è°ƒç”¨destoryé”€æ¯ï¼Œå°†å†…å­˜åœ°å€è¿”å›ç»™ç³»ç»Ÿï¼Œä»£è¡¨è¿™éƒ¨åˆ†åœ°å€ä½¿ç”¨å¼•ç”¨-1ï¼‰




#### relational operators (vector)

#### swap (vector)

#### vector <bool>

### deque

dequeï¼ˆ['dek]ï¼‰ï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ˜¯double-ended queue çš„ä¸€ä¸ªä¸è§„åˆ™ç¼©å†™ã€‚dequeæ˜¯å…·æœ‰åŠ¨æ€å¤§å°çš„åºåˆ—å®¹å™¨ï¼Œå¯ä»¥åœ¨ä¸¤ç«¯ï¼ˆå‰ç«¯æˆ–åç«¯ï¼‰æ‰©å±•æˆ–æ”¶ç¼©ã€‚

ç‰¹å®šçš„åº“å¯ä»¥ä»¥ä¸åŒçš„æ–¹å¼å®ç°dequesï¼Œé€šå¸¸ä½œä¸ºæŸç§å½¢å¼çš„åŠ¨æ€æ•°ç»„ã€‚ä½†æ˜¯åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå®ƒä»¬éƒ½å…è®¸é€šè¿‡éšæœºè®¿é—®è¿­ä»£å™¨ç›´æ¥è®¿é—®å„ä¸ªå…ƒç´ ï¼Œé€šè¿‡æ ¹æ®éœ€è¦æ‰©å±•å’Œæ”¶ç¼©å®¹å™¨æ¥è‡ªåŠ¨å¤„ç†å­˜å‚¨ã€‚

å› æ­¤ï¼Œå®ƒä»¬æä¾›äº†ç±»ä¼¼äºvectorçš„åŠŸèƒ½ï¼Œä½†æ˜¯åœ¨åºåˆ—çš„å¼€å§‹éƒ¨åˆ†ä¹Ÿå¯ä»¥é«˜æ•ˆåœ°æ’å…¥å’Œåˆ é™¤å…ƒç´ ï¼Œè€Œä¸ä»…ä»…æ˜¯åœ¨ç»“å°¾ã€‚ä½†æ˜¯ï¼Œä¸vectorä¸åŒï¼Œdequeså¹¶ä¸ä¿è¯å°†å…¶æ‰€æœ‰å…ƒç´ å­˜å‚¨åœ¨è¿ç»­çš„å­˜å‚¨ä½ç½®ï¼šdequeé€šè¿‡åç§»æŒ‡å‘å¦ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆè®¿é—®å…ƒç´ ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚

ä¸¤ä¸ªvectorå’Œdequesæä¾›äº†ä¸€ä¸ªéå¸¸ç›¸ä¼¼çš„æ¥å£ï¼Œå¯ä»¥ç”¨äºç±»ä¼¼çš„ç›®çš„ï¼Œä½†å†…éƒ¨å·¥ä½œæ–¹å¼å®Œå…¨ä¸åŒï¼šè™½ç„¶vectorä½¿ç”¨å•ä¸ªæ•°ç»„éœ€è¦å¶å°”é‡æ–°åˆ†é…ä»¥å¢é•¿ï¼Œä½†æ˜¯dequeçš„å…ƒç´ å¯ä»¥åˆ†æ•£åœ¨ä¸åŒçš„å—çš„å®¹å™¨ï¼Œå®¹å™¨åœ¨å†…éƒ¨ä¿å­˜å¿…è¦çš„ä¿¡æ¯ä»¥æä¾›å¯¹å…¶ä»»ä½•å…ƒç´ çš„æŒç»­æ—¶é—´å’Œç»Ÿä¸€çš„é¡ºåºæ¥å£ï¼ˆé€šè¿‡è¿­ä»£å™¨ï¼‰çš„ç›´æ¥è®¿é—®ã€‚å› æ­¤ï¼Œdequesåœ¨å†…éƒ¨æ¯”vectoræ›´å¤æ‚ä¸€ç‚¹ï¼Œä½†æ˜¯è¿™ä½¿å¾—ä»–ä»¬åœ¨æŸäº›æƒ…å†µä¸‹æ›´æœ‰æ•ˆåœ°å¢é•¿ï¼Œå°¤å…¶æ˜¯åœ¨é‡æ–°åˆ†é…å˜å¾—æ›´åŠ æ˜‚è´µçš„å¾ˆé•¿åºåˆ—çš„æƒ…å†µä¸‹ã€‚

å¯¹äºé¢‘ç¹æ’å…¥æˆ–åˆ é™¤å¼€å§‹æˆ–ç»“æŸä½ç½®ä»¥å¤–çš„å…ƒç´ çš„æ“ä½œï¼Œdequesè¡¨ç°å¾—æ›´å·®ï¼Œå¹¶ä¸”ä¸åˆ—è¡¨å’Œè½¬å‘åˆ—è¡¨ç›¸æ¯”ï¼Œè¿­ä»£å™¨å’Œå¼•ç”¨çš„ä¸€è‡´æ€§æ›´ä½ã€‚

dequeä¸Šå¸¸è§æ“ä½œçš„å¤æ‚æ€§ï¼ˆæ•ˆç‡ï¼‰å¦‚ä¸‹ï¼š 

* éšæœºè®¿é—® - å¸¸æ•°O(1) 
* åœ¨ç»“å°¾æˆ–å¼€å¤´æ’å…¥æˆ–ç§»é™¤å…ƒç´  - æ‘Šé”€ä¸å˜O(1) 
* æ’å…¥æˆ–ç§»é™¤å…ƒç´  - çº¿æ€§O(n)

```cpp
template < class T, class Alloc = allocator<T> > class deque;
```

![](assets/stlæ€»ç»“/20170727225856144)
![](assets/stlæ€»ç»“/092150340824.png)

#### deque::deque

æ„é€ ä¸€ä¸ªdequeå®¹å™¨å¯¹è±¡ï¼Œæ ¹æ®æ‰€ä½¿ç”¨çš„æ„é€ å‡½æ•°ç‰ˆæœ¬åˆå§‹åŒ–å®ƒçš„å†…å®¹ï¼š

Example

```cpp
#include <iostream>
#include <deque>

int main ()
{
  unsigned int i;

  // constructors used in the same order as described above:
  std::deque<int> first;                                // empty deque of ints
  std::deque<int> second (4,100);                       // four ints with value 100
  std::deque<int> third (second.begin(),second.end());  // iterating through second
  std::deque<int> fourth (third);                       // a copy of third

  // the iterator constructor can be used to copy arrays:
  int myints[] = {16,2,77,29};
  std::deque<int> fifth (myints, myints + sizeof(myints) / sizeof(int) );

  std::cout << "The contents of fifth are:";
  for (std::deque<int>::iterator it = fifth.begin(); it!=fifth.end(); ++it)
    std::cout << ' ' << *it;

  std::cout << '\n';

  return 0;
}
```

Output

```
The contents of fifth are: 16 2 77 29 
```

#### deque::push_back

åœ¨å½“å‰çš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å ï¼Œåœ¨dequeå®¹å™¨çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªæ–°å…ƒç´ ã€‚valçš„å†…å®¹è¢«å¤åˆ¶ï¼ˆæˆ–ç§»åŠ¨ï¼‰åˆ°æ–°çš„å…ƒç´ ã€‚

è¿™æœ‰æ•ˆåœ°å¢åŠ äº†ä¸€ä¸ªå®¹å™¨çš„å¤§å°ã€‚

```cpp
void push_back (const value_type& val);
void push_back (value_type&& val);
```

Example

```cpp
#include <iostream>
#include <deque>

int main ()
{
  std::deque<int> mydeque;
  int myint;

  std::cout << "Please enter some integers (enter 0 to end):\n";

  do {
    std::cin >> myint;
    mydeque.push_back (myint);
  } while (myint);

  std::cout << "mydeque stores " << (int) mydeque.size() << " numbers.\n";

  return 0;
}
```

#### deque::push_front

åœ¨dequeå®¹å™¨çš„å¼€å§‹ä½ç½®æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œä½äºå½“å‰çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ã€‚valçš„å†…å®¹è¢«å¤åˆ¶ï¼ˆæˆ–ç§»åŠ¨ï¼‰åˆ°æ’å…¥çš„å…ƒç´ ã€‚

è¿™æœ‰æ•ˆåœ°å¢åŠ äº†ä¸€ä¸ªå®¹å™¨çš„å¤§å°ã€‚

```cpp
void push_front (const value_type& val);
void push_front (value_type&& val);
```

Example

```cpp
#include <iostream>
#include <deque>

int main ()
{
  std::deque<int> mydeque (2,100);     // two ints with a value of 100
  mydeque.push_front (200);
  mydeque.push_front (300);

  std::cout << "mydeque contains:";
  for (std::deque<int>::iterator it = mydeque.begin(); it != mydeque.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
```

Output

```
300 200 100 100
```

#### deque::pop_back

åˆ é™¤dequeå®¹å™¨ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæœ‰æ•ˆåœ°å°†å®¹å™¨å¤§å°å‡å°‘ä¸€ä¸ªã€‚

è¿™ç ´åäº†è¢«åˆ é™¤çš„å…ƒç´ ã€‚

```cpp
void pop_back();
```

Example

```cpp
#include <iostream>
#include <deque>

int main ()
{
  std::deque<int> mydeque;
  int sum (0);
  mydeque.push_back (10);
  mydeque.push_back (20);
  mydeque.push_back (30);

  while (!mydeque.empty())
  {
    sum+=mydeque.back();
    mydeque.pop_back();
  }

  std::cout << "The elements of mydeque add up to " << sum << '\n';

  return 0;
}
```

Output

```
The elements of mydeque add up to 60
```

#### deque::pop_front

åˆ é™¤dequeå®¹å™¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæœ‰æ•ˆåœ°å‡å°å…¶å¤§å°ã€‚

è¿™ç ´åäº†è¢«åˆ é™¤çš„å…ƒç´ ã€‚

```cpp
void pop_front();
```

Example

```cpp
#include <iostream>
#include <deque>

int main ()
{
  std::deque<int> mydeque;

  mydeque.push_back (100);
  mydeque.push_back (200);
  mydeque.push_back (300);

  std::cout << "Popping out the elements in mydeque:";
  while (!mydeque.empty())
  {
    std::cout << ' ' << mydeque.front();
    mydeque.pop_front();
  }

  std::cout << "\nThe final size of mydeque is " << int(mydeque.size()) << '\n';

  return 0;
}
```

Output

```
Popping out the elements in mydeque: 100 200 300
The final size of mydeque is 0
```

#### deque::emplace_front

åœ¨dequeçš„å¼€å¤´æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œå°±åœ¨å…¶å½“å‰çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ã€‚è¿™ä¸ªæ–°çš„å…ƒç´ æ˜¯ç”¨argsä½œä¸ºæ„å»ºçš„å‚æ•°æ¥æ„å»ºçš„ã€‚

è¿™æœ‰æ•ˆåœ°å¢åŠ äº†ä¸€ä¸ªå®¹å™¨çš„å¤§å°ã€‚

è¯¥å…ƒç´ æ˜¯é€šè¿‡è°ƒç”¨allocator_traits::constructæ¥è½¬æ¢argsæ¥åˆ›å»ºçš„ã€‚

å­˜åœ¨ä¸€ä¸ªç±»ä¼¼çš„æˆå‘˜å‡½æ•°push_frontï¼Œå®ƒå¯ä»¥å°†ç°æœ‰å¯¹è±¡å¤åˆ¶æˆ–ç§»åŠ¨åˆ°å®¹å™¨ä¸­ã€‚

```cpp
template <class... Args>
  void emplace_front (Args&&... args);
```

Example

```cpp
#include <iostream>
#include <deque>

int main ()
{
  std::deque<int> mydeque = {10,20,30};

  mydeque.emplace_front (111);
  mydeque.emplace_front (222);

  std::cout << "mydeque contains:";
  for (auto& x: mydeque)
    std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```

Output

```
mydeque contains: 222 111 10 20 30
```

#### deque::emplace_back

åœ¨dequeçš„æœ«å°¾æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œç´§è·Ÿåœ¨å½“å‰çš„æœ€åä¸€ä¸ªå…ƒç´ ä¹‹åã€‚è¿™ä¸ªæ–°çš„å…ƒç´ æ˜¯ç”¨argsä½œä¸ºæ„å»ºçš„å‚æ•°æ¥æ„å»ºçš„ã€‚

è¿™æœ‰æ•ˆåœ°å¢åŠ äº†ä¸€ä¸ªå®¹å™¨çš„å¤§å°ã€‚

è¯¥å…ƒç´ æ˜¯é€šè¿‡è°ƒç”¨allocator_traits::constructæ¥è½¬æ¢argsæ¥åˆ›å»ºçš„ã€‚

å­˜åœ¨ä¸€ä¸ªç±»ä¼¼çš„æˆå‘˜å‡½æ•°push_backï¼Œå®ƒå¯ä»¥å°†ç°æœ‰å¯¹è±¡å¤åˆ¶æˆ–ç§»åŠ¨åˆ°å®¹å™¨ä¸­

```cpp
template <class... Args>
  void emplace_back (Args&&... args);
```

Example

```cpp
#include <iostream>
#include <deque>

int main ()
{
  std::deque<int> mydeque = {10,20,30};

  mydeque.emplace_back (100);
  mydeque.emplace_back (200);

  std::cout << "mydeque contains:";
  for (auto& x: mydeque)
    std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```

Output

```
mydeque contains: 10 20 30 100 200
```

### forward\_list

forward_listï¼ˆå•å‘é“¾è¡¨ï¼‰æ˜¯åºåˆ—å®¹å™¨ï¼Œå…è®¸åœ¨åºåˆ—ä¸­çš„ä»»ä½•åœ°æ–¹è¿›è¡Œæ’å®šçš„æ—¶é—´æ’å…¥å’Œæ“¦é™¤æ“ä½œã€‚

forward\_listï¼ˆå•å‘é“¾è¡¨ï¼‰è¢«å®ç°ä¸ºå•é“¾è¡¨; å•é“¾è¡¨å¯ä»¥å°†å®ƒä»¬åŒ…å«çš„æ¯ä¸ªå…ƒç´ å­˜å‚¨åœ¨ä¸åŒå’Œä¸ç›¸å…³çš„å­˜å‚¨ä½ç½®ä¸­ã€‚é€šè¿‡å…³è”åˆ°åºåˆ—ä¸­ä¸‹ä¸€ä¸ªå…ƒç´ çš„é“¾æ¥çš„æ¯ä¸ªå…ƒç´ æ¥ä¿ç•™æ’åºã€‚forward\_listå®¹å™¨å’Œåˆ—è¡¨

ä¹‹é—´çš„ä¸»è¦è®¾è®¡åŒºåˆ«å®¹å™¨æ˜¯ç¬¬ä¸€ä¸ªå†…éƒ¨åªä¿ç•™ä¸€ä¸ªåˆ°ä¸‹ä¸€ä¸ªå…ƒç´ çš„é“¾æ¥ï¼Œè€Œåè€…æ¯ä¸ªå…ƒç´ ä¿ç•™ä¸¤ä¸ªé“¾æ¥ï¼šä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œä¸€ä¸ªæŒ‡å‘å‰ä¸€ä¸ªå…ƒç´ ï¼Œå…è®¸åœ¨ä¸¤ä¸ªæ–¹å‘ä¸Šæœ‰æ•ˆçš„è¿­ä»£ï¼Œä½†æ˜¯æ¯ä¸ªå…ƒç´ æ¶ˆè€—é¢å¤–çš„å­˜å‚¨ç©ºé—´å¹¶ä¸”æ’å…¥å’Œç§»é™¤å…ƒä»¶çš„æ—¶é—´å¼€é”€ç•¥é«˜ã€‚å› æ­¤ï¼Œforward_listå¯¹è±¡æ¯”åˆ—è¡¨å¯¹è±¡æ›´æœ‰æ•ˆç‡ï¼Œå°½ç®¡å®ƒä»¬åªèƒ½å‘å‰è¿­ä»£ã€‚

ä¸å…¶ä»–åŸºæœ¬çš„æ ‡å‡†åºåˆ—å®¹å™¨ï¼ˆarrayï¼Œvectorå’Œdequeï¼‰ï¼Œforward_listé€šå¸¸åœ¨æ’å…¥ï¼Œæå–å’Œç§»åŠ¨å®¹å™¨å†…ä»»ä½•ä½ç½®çš„å…ƒç´ æ–¹é¢æ•ˆæœæ›´å¥½ï¼Œå› æ­¤ä¹Ÿé€‚ç”¨äºå¯†é›†ä½¿ç”¨è¿™äº›å…ƒç´ çš„ç®—æ³•ï¼Œå¦‚æ’åºç®—æ³•ã€‚

çš„ä¸»è¦ç¼ºç‚¹ä¿®é¥°ç¬¦Modifiers Så’Œåˆ—è¡¨ç›¸æ¯”è¿™äº›å…¶å®ƒåºåˆ—å®¹å™¨sæ˜¯è¯´ï¼Œä»–ä»¬ç¼ºä¹å¯ä»¥é€šè¿‡ä½ç½®çš„å…ƒç´ çš„ç›´æ¥è®¿é—®; ä¾‹å¦‚ï¼Œè¦è®¿é—®forward_listä¸­çš„ç¬¬å…­ä¸ªå…ƒç´ ï¼Œå¿…é¡»ä»å¼€å§‹ä½ç½®è¿­ä»£åˆ°è¯¥ä½ç½®ï¼Œè¿™éœ€è¦åœ¨è¿™äº›ä½ç½®ä¹‹é—´çš„çº¿æ€§æ—¶é—´ã€‚å®ƒä»¬è¿˜æ¶ˆè€—ä¸€äº›é¢å¤–çš„å†…å­˜æ¥ä¿æŒä¸æ¯ä¸ªå…ƒç´ ç›¸å…³è”çš„é“¾æ¥ä¿¡æ¯ï¼ˆè¿™å¯èƒ½æ˜¯å¤§å‹å°å…ƒç´ åˆ—è¡¨çš„é‡è¦å› ç´ ï¼‰ã€‚

è¯¥ä¿®é¥°ç¬¦Modifiersclassæ¨¡æ¿çš„è®¾è®¡è€ƒè™‘åˆ°æ•ˆç‡ï¼šæŒ‰ç…§è®¾è®¡ï¼Œå®ƒä¸ç®€å•çš„æ‰‹å†™Cå‹å•é“¾è¡¨ä¸€æ ·é«˜æ•ˆï¼Œå®é™…ä¸Šæ˜¯å”¯ä¸€çš„æ ‡å‡†å®¹å™¨ï¼Œä¸ºäº†æ•ˆç‡çš„è€ƒè™‘æ•…æ„ç¼ºå°‘å°ºå¯¸æˆå‘˜å‡½æ•°ï¼šç”±äºå…¶æ€§è´¨ä½œä¸ºä¸€ä¸ªé“¾è¡¨ï¼Œå…·æœ‰ä¸€ä¸ªéœ€è¦ä¸€å®šæ—¶é—´çš„å¤§å°çš„æˆå‘˜å°†éœ€è¦å®ƒä¿æŒä¸€ä¸ªå†…éƒ¨è®¡æ•°å™¨çš„å¤§å°ï¼ˆå¦‚åˆ—è¡¨æ‰€ç¤ºï¼‰ã€‚è¿™ä¼šæ¶ˆè€—ä¸€äº›é¢å¤–çš„å­˜å‚¨ç©ºé—´ï¼Œå¹¶ä½¿æ’å…¥å’Œåˆ é™¤æ“ä½œæ•ˆç‡ç¨ä½ã€‚è¦è·å–forward_listå¯¹è±¡çš„å¤§å°ï¼Œå¯ä»¥ä½¿ç”¨è·ç¦»ç®—æ³•çš„å¼€å§‹å’Œç»“æŸï¼Œè¿™æ˜¯ä¸€ä¸ªéœ€è¦çº¿æ€§æ—¶é—´çš„æ“ä½œã€‚

![](assets/stlæ€»ç»“/20160407212133266)

#### forward\_list::forward\_list

```cpp
default (1)	
explicit forward_list (const allocator_type& alloc = allocator_type());
fill (2)	
explicit forward_list (size_type n);
explicit forward_list (size_type n, const value_type& val,
                        const allocator_type& alloc = allocator_type());
range (3)	
template <class InputIterator>
  forward_list (InputIterator first, InputIterator last,
                const allocator_type& alloc = allocator_type());
copy (4)	
forward_list (const forward_list& fwdlst);
forward_list (const forward_list& fwdlst, const allocator_type& alloc);
move (5)	
forward_list (forward_list&& fwdlst);
forward_list (forward_list&& fwdlst, const allocator_type& alloc);
initializer list (6)	
forward_list (initializer_list<value_type> il,
              const allocator_type& alloc = allocator_type());
```

Example

```cpp
#include <iostream>
#include <forward_list>

int main ()
{
  // constructors used in the same order as described above:

  std::forward_list<int> first;                      // default: empty
  std::forward_list<int> second (3,77);              // fill: 3 seventy-sevens
  std::forward_list<int> third (second.begin(), second.end()); // range initialization
  std::forward_list<int> fourth (third);            // copy constructor
  std::forward_list<int> fifth (std::move(fourth));  // move ctor. (fourth wasted)
  std::forward_list<int> sixth = {3, 52, 25, 90};    // initializer_list constructor

  std::cout << "first:" ; for (int& x: first)  std::cout << " " << x; std::cout << '\n';
  std::cout << "second:"; for (int& x: second) std::cout << " " << x; std::cout << '\n';
  std::cout << "third:";  for (int& x: third)  std::cout << " " << x; std::cout << '\n';
  std::cout << "fourth:"; for (int& x: fourth) std::cout << " " << x; std::cout << '\n';
  std::cout << "fifth:";  for (int& x: fifth)  std::cout << " " << x; std::cout << '\n';
  std::cout << "sixth:";  for (int& x: sixth)  std::cout << " " << x; std::cout << '\n';

  return 0;
}
```

Possible output

```
forward_list constructor examples:
first:
second: 77 77 77
third: 77 77 77
fourth:
fifth: 77 77 77
sixth: 3 52 25 90
```

#### forward\_list::~forward\_list

#### forward\_list::before\_begin

è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ä½ç½®çš„è¿­ä»£å™¨ã€‚

è¿”å›çš„è¿­ä»£å™¨ä¸åº”è¢«è§£é™¤å¼•ç”¨ï¼šå®ƒæ˜¯ä¸ºäº†ç”¨ä½œæˆå‘˜å‡½æ•°çš„å‚æ•°emplace\_afterï¼Œinsert\_afterï¼Œerase\_afteræˆ–splice\_afterï¼ŒæŒ‡å®šåºåˆ—ï¼Œå…¶ä¸­æ‰§è¡Œè¯¥åŠ¨ä½œçš„ä½ç½®çš„å¼€å§‹ä½ç½®ã€‚

```cpp
      iterator before_begin() noexcept;
const_iterator before_begin() const noexcept;
```

Example

```cpp
#include <iostream>
#include <forward_list>

int main ()
{
  std::forward_list<int> mylist = {20, 30, 40, 50};

  mylist.insert_after ( mylist.before_begin(), 11 );

  std::cout << "mylist contains:";
  for ( int& x: mylist ) std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```

Output

```
mylist contains: 11 20 30 40 50
```

#### forward\_list::cbefore\_begin

è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ä½ç½®çš„const_iteratorã€‚

ä¸€ä¸ªå¸¸é‡æ€§æ˜¯æŒ‡å‘å¸¸é‡å†…å®¹çš„è¿­ä»£å™¨ã€‚è¿™ä¸ªè¿­ä»£å™¨å¯ä»¥å¢åŠ å’Œå‡å°‘ï¼ˆé™¤éå®ƒæœ¬èº«ä¹Ÿæ˜¯constï¼‰ï¼Œå°±åƒforward\_list::before\_beginè¿”å›çš„è¿­ä»£å™¨ä¸€æ ·ï¼Œä½†ä¸èƒ½ç”¨æ¥ä¿®æ”¹å®ƒæŒ‡å‘çš„å†…å®¹ã€‚

è¿”å›çš„ä»·å€¼ä¸å¾—è§£é™¤å¼•ç”¨ã€‚

```cpp
const_iterator cbefore_begin() const noexcept;
```

Example

```cpp
#include <iostream>
#include <forward_list>

int main ()
{
  std::forward_list<int> mylist = {77, 2, 16};

  mylist.insert_after ( mylist.cbefore_begin(), 19 );

  std::cout << "mylist contains:";
  for ( int& x: mylist ) std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```

Output

```
mylist contains: 19 77 2 16
```

### list

### stack

### queue

### priority_queue

### set

### multiset

### map

map æ˜¯å…³è”å®¹å™¨ï¼ŒæŒ‰ç…§ç‰¹å®šé¡ºåºå­˜å‚¨ç”± key value (é”®å€¼) å’Œ mapped value (æ˜ å°„å€¼) ç»„åˆå½¢æˆçš„å…ƒç´ ã€‚

åœ¨æ˜ å°„ä¸­ï¼Œé”®å€¼é€šå¸¸ç”¨äºå¯¹å…ƒç´ è¿›è¡Œæ’åºå’Œå”¯ä¸€æ ‡è¯†ï¼Œè€Œæ˜ å°„çš„å€¼å­˜å‚¨ä¸æ­¤é”®å…³è”çš„å†…å®¹ã€‚è¯¥ç±»å‹çš„é”®å’Œæ˜ å°„çš„å€¼å¯èƒ½ä¸åŒï¼Œå¹¶ä¸”åœ¨éƒ¨ä»¶ç±»å‹è¢«åˆ†ç»„åœ¨ä¸€èµ·VALUE_TYPEï¼Œè¿™æ˜¯ä¸€ç§å¯¹ç±»å‹ç»“åˆä¸¤ç§ï¼š

```cpp
typedef pair<const Key, T> value_type;
```

åœ¨å†…éƒ¨ï¼Œæ˜ å°„ä¸­çš„å…ƒç´ æ€»æ˜¯æŒ‰ç…§ç”±å…¶å†…éƒ¨æ¯”è¾ƒå¯¹è±¡ï¼ˆæ¯”è¾ƒç±»å‹ï¼‰æŒ‡ç¤ºçš„ç‰¹å®šçš„ä¸¥æ ¼å¼±æ’åºæ ‡å‡†æŒ‰é”®æ’åºã€‚æ˜ å°„å®¹å™¨é€šå¸¸æ¯”unordered_mapå®¹å™¨æ…¢ï¼Œä»¥é€šè¿‡å®ƒä»¬çš„é”®æ¥è®¿é—®å„ä¸ªå…ƒç´ ï¼Œä½†æ˜¯å®ƒä»¬å…è®¸åŸºäºå®ƒä»¬çš„é¡ºåºå¯¹å­é›†è¿›è¡Œç›´æ¥è¿­ä»£ã€‚ åœ¨è¯¥æ˜ å°„å€¼åœ°å›¾å¯ä»¥ç›´æ¥é€šè¿‡ä½¿ç”¨å…¶ç›¸åº”çš„é”®æ¥è®¿é—®æ‹¬å·è¿ç®—ç¬¦ï¼ˆï¼ˆæ“ä½œç¬¦[] ï¼‰ã€‚ æ˜ å°„é€šå¸¸å¦‚å®æ–½

```cpp
template < class Key,                                     // map::key_type
           class T,                                       // map::mapped_type
           class Compare = less<Key>,                     // map::key_compare
           class Alloc = allocator<pair<const Key,T> >    // map::allocator_type
           > class map;
```

#### map::map

æ„é€ ä¸€ä¸ªæ˜ å°„å®¹å™¨å¯¹è±¡ï¼Œæ ¹æ®æ‰€ä½¿ç”¨çš„æ„é€ å™¨ç‰ˆæœ¬åˆå§‹åŒ–å…¶å†…å®¹ï¼š

ï¼ˆ1ï¼‰ç©ºå®¹å™¨æ„é€ å‡½æ•°ï¼ˆé»˜è®¤æ„é€ å‡½æ•°ï¼‰

æ„é€ ä¸€ä¸ªç©ºçš„å®¹å™¨ï¼Œæ²¡æœ‰å…ƒç´ ã€‚

ï¼ˆ2ï¼‰èŒƒå›´æ„é€ å‡½æ•°

æ„é€ å…·æœ‰ä¸€æ ·å¤šçš„å…ƒç´ çš„èŒƒå›´å†…çš„å®¹å™¨[ç¬¬ä¸€ï¼Œæœ€åä¸€ä¸ªï¼‰ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒä»¶å¸ƒè®¾æ„é€ çš„ä»åœ¨è¯¥èŒƒå›´å†…å®ƒçš„ç›¸åº”çš„å…ƒä»¶ã€‚

ï¼ˆ3ï¼‰å¤åˆ¶æ„é€ å‡½æ•°ï¼ˆå¹¶ç”¨åˆ†é…å™¨å¤åˆ¶ï¼‰

ä½¿ç”¨xä¸­çš„æ¯ä¸ªå…ƒç´ çš„å‰¯æœ¬æ„é€ ä¸€ä¸ªå®¹å™¨ã€‚

ï¼ˆ4ï¼‰ç§»åŠ¨æ„é€ å‡½æ•°ï¼ˆå¹¶ä¸åˆ†é…å™¨ä¸€èµ·ç§»åŠ¨ï¼‰

æ„é€ ä¸€ä¸ªè·å–xå…ƒç´ çš„å®¹å™¨ã€‚
å¦‚æœæŒ‡å®šäº†allocå¹¶ä¸”ä¸xçš„åˆ†é…å™¨ä¸åŒï¼Œé‚£ä¹ˆå…ƒç´ å°†è¢«ç§»åŠ¨ã€‚å¦åˆ™ï¼Œæ²¡æœ‰æ„å»ºå…ƒç´ ï¼ˆä»–ä»¬çš„æ‰€æœ‰æƒç›´æ¥è½¬ç§»ï¼‰ã€‚
xä¿æŒæœªæŒ‡å®šä½†æœ‰æ•ˆçš„çŠ¶æ€ã€‚

ï¼ˆ5ï¼‰åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°

ç”¨ilä¸­çš„æ¯ä¸ªå…ƒç´ çš„å‰¯æœ¬æ„é€ ä¸€ä¸ªå®¹å™¨ã€‚

```cpp
empty (1)	
explicit map (const key_compare& comp = key_compare(),
              const allocator_type& alloc = allocator_type());
explicit map (const allocator_type& alloc);
range (2)	
template <class InputIterator>
  map (InputIterator first, InputIterator last,
       const key_compare& comp = key_compare(),
       const allocator_type& = allocator_type());
copy (3)	
map (const map& x);
map (const map& x, const allocator_type& alloc);
move (4)	
map (map&& x);
map (map&& x, const allocator_type& alloc);
initializer list (5)	
map (initializer_list<value_type> il,
     const key_compare& comp = key_compare(),
     const allocator_type& alloc = allocator_type());
```

Example

```cpp
#include <iostream>
#include <map>

bool fncomp (char lhs, char rhs) {return lhs<rhs;}

struct classcomp {
  bool operator() (const char& lhs, const char& rhs) const
  {return lhs<rhs;}
};

int main ()
{
  std::map<char,int> first;

  first['a']=10;
  first['b']=30;
  first['c']=50;
  first['d']=70;

  std::map<char,int> second (first.begin(),first.end());

  std::map<char,int> third (second);

  std::map<char,int,classcomp> fourth;                 // class as Compare

  bool(*fn_pt)(char,char) = fncomp;
  std::map<char,int,bool(*)(char,char)> fifth (fn_pt); // function pointer as Compare

  return 0;
}
```

#### map::begin

è¿”å›å¼•ç”¨mapå®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚

ç”±äºmapå®¹å™¨å§‹ç»ˆä¿æŒå…¶å…ƒç´ çš„é¡ºåºï¼Œæ‰€ä»¥å¼€å§‹æŒ‡å‘éµå¾ªå®¹å™¨æ’åºæ ‡å‡†çš„å…ƒç´ ã€‚

å¦‚æœå®¹å™¨æ˜¯ç©ºçš„ï¼Œåˆ™è¿”å›çš„è¿­ä»£å™¨å€¼ä¸åº”è¢«è§£é™¤å¼•ç”¨ã€‚

```cpp
      iterator begin() noexcept;
const_iterator begin() const noexcept;
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;

  mymap['b'] = 100;
  mymap['a'] = 200;
  mymap['c'] = 300;

  // show content:
  for (std::map<char,int>::iterator it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';

  return 0;
}
```

Output

```
a => 200
b => 100
c => 300
```

#### map::key_comp

è¿”å›å®¹å™¨ç”¨äºæ¯”è¾ƒé”®çš„æ¯”è¾ƒå¯¹è±¡çš„å‰¯æœ¬ã€‚ 

```cpp
key_compare key_comp() const;
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;

  std::map<char,int>::key_compare mycomp = mymap.key_comp();

  mymap['a']=100;
  mymap['b']=200;
  mymap['c']=300;

  std::cout << "mymap contains:\n";

  char highest = mymap.rbegin()->first;     // key value of last element

  std::map<char,int>::iterator it = mymap.begin();
  do {
    std::cout << it->first << " => " << it->second << '\n';
  } while ( mycomp((*it++).first, highest) );

  std::cout << '\n';

  return 0;
}
```

Output

```
mymap contains:
a => 100
b => 200
c => 300
```

#### map::value_comp

è¿”å›å¯ç”¨äºæ¯”è¾ƒä¸¤ä¸ªå…ƒç´ çš„æ¯”è¾ƒå¯¹è±¡ï¼Œä»¥è·å–ç¬¬ä¸€ä¸ªå…ƒç´ çš„é”®æ˜¯å¦åœ¨ç¬¬äºŒä¸ªå…ƒç´ ä¹‹å‰ã€‚

```cpp
value_compare value_comp() const;
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;

  mymap['x']=1001;
  mymap['y']=2002;
  mymap['z']=3003;

  std::cout << "mymap contains:\n";

  std::pair<char,int> highest = *mymap.rbegin();          // last element

  std::map<char,int>::iterator it = mymap.begin();
  do {
    std::cout << it->first << " => " << it->second << '\n';
  } while ( mymap.value_comp()(*it++, highest) );

  return 0;
}
```

Output

```
mymap contains:
x => 1001
y => 2002
z => 3003
```

#### map::find

åœ¨å®¹å™¨ä¸­æœç´¢å…·æœ‰ç­‰äºkçš„é”®çš„å…ƒç´ ï¼Œå¦‚æœæ‰¾åˆ°åˆ™è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å›map::endçš„è¿­ä»£å™¨ã€‚

å¦‚æœå®¹å™¨çš„æ¯”è¾ƒå¯¹è±¡è‡ªååœ°è¿”å›å‡ï¼ˆå³ï¼Œä¸ç®¡å…ƒç´ ä½œä¸ºå‚æ•°ä¼ é€’çš„é¡ºåºï¼‰ï¼Œåˆ™ä¸¤ä¸ªkeyè¢«è®¤ä¸ºæ˜¯ç­‰åŒçš„ã€‚ 

å¦ä¸€ä¸ªæˆå‘˜å‡½æ•°map::countå¯ä»¥ç”¨æ¥æ£€æŸ¥ä¸€ä¸ªç‰¹å®šçš„é”®æ˜¯å¦å­˜åœ¨ã€‚

```cpp
      iterator find (const key_type& k);
const_iterator find (const key_type& k) const;
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;
  std::map<char,int>::iterator it;

  mymap['a']=50;
  mymap['b']=100;
  mymap['c']=150;
  mymap['d']=200;

  it = mymap.find('b');
  if (it != mymap.end())
    mymap.erase (it);

  // print content:
  std::cout << "elements in mymap:" << '\n';
  std::cout << "a => " << mymap.find('a')->second << '\n';
  std::cout << "c => " << mymap.find('c')->second << '\n';
  std::cout << "d => " << mymap.find('d')->second << '\n';

  return 0;
}
```

Output

```
elements in mymap:
a => 50
c => 150
d => 200
```

#### map::count

åœ¨å®¹å™¨ä¸­æœç´¢å…·æœ‰ç­‰äºkçš„é”®çš„å…ƒç´ ï¼Œå¹¶è¿”å›åŒ¹é…çš„æ•°é‡ã€‚

ç”±äºåœ°å›¾å®¹å™¨ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œå› æ­¤è¯¥å‡½æ•°åªèƒ½è¿”å›1ï¼ˆå¦‚æœæ‰¾åˆ°è¯¥å…ƒç´ ï¼‰æˆ–è¿”å›é›¶ï¼ˆå¦åˆ™ï¼‰ã€‚

å¦‚æœå®¹å™¨çš„æ¯”è¾ƒå¯¹è±¡è‡ªååœ°è¿”å›é”™è¯¯ï¼ˆå³ï¼Œä¸ç®¡æŒ‰é”®ä½œä¸ºå‚æ•°ä¼ é€’çš„é¡ºåºï¼‰ï¼Œåˆ™ä¸¤ä¸ªé”®è¢«è®¤ä¸ºæ˜¯ç­‰åŒçš„ã€‚

```cpp
size_type count (const key_type& k) const;
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;
  char c;

  mymap ['a']=101;
  mymap ['c']=202;
  mymap ['f']=303;

  for (c='a'; c<'h'; c++)
  {
    std::cout << c;
    if (mymap.count(c)>0)
      std::cout << " is an element of mymap.\n";
    else 
      std::cout << " is not an element of mymap.\n";
  }

  return 0;
}
```

Output

```
a is an element of mymap.
b is not an element of mymap.
c is an element of mymap.
d is not an element of mymap.
e is not an element of mymap.
f is an element of mymap.
g is not an element of mymap.
```

#### map::lower_bound

å°†è¿­ä»£å™¨è¿”å›åˆ°ä¸‹é™

è¿”å›æŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼Œè¯¥å…ƒç´ çš„é”®ä¸ä¼šåœ¨kä¹‹å‰å‡ºç°ï¼ˆå³ï¼Œå®ƒæ˜¯ç­‰ä»·çš„æˆ–è€…åœ¨å…¶åï¼‰ã€‚

è¯¥å‡½æ•°ä½¿ç”¨å…¶å†…éƒ¨æ¯”è¾ƒå¯¹è±¡ï¼ˆkey\_compï¼‰æ¥ç¡®å®šè¿™ä¸€ç‚¹ï¼Œå°†è¿­ä»£å™¨è¿”å›åˆ°key\_compï¼ˆelement\_keyï¼Œkï¼‰å°†è¿”å›falseçš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

å¦‚æœmapç±»ç”¨é»˜è®¤çš„æ¯”è¾ƒç±»å‹ï¼ˆlessï¼‰å®ä¾‹åŒ–ï¼Œåˆ™å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå…¶é”®ä¸å°äºkã€‚

ä¸€ä¸ªç±»ä¼¼çš„æˆå‘˜å‡½æ•°upper\_boundå…·æœ‰ç›¸åŒçš„è¡Œä¸ºlower\_boundï¼Œé™¤éæ˜ å°„åŒ…å«ä¸€ä¸ªkeyå€¼ç­‰äºkçš„å…ƒç´ ï¼šåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œlower\_boundè¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ï¼Œè€Œupper\_boundè¿”å›æŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚

```cpp
      iterator lower_bound (const key_type& k);
const_iterator lower_bound (const key_type& k) const;
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;
  std::map<char,int>::iterator itlow,itup;

  mymap['a']=20;
  mymap['b']=40;
  mymap['c']=60;
  mymap['d']=80;
  mymap['e']=100;

  itlow=mymap.lower_bound ('b');  // itlow points to b
  itup=mymap.upper_bound ('d');   // itup points to e (not d!)

  mymap.erase(itlow,itup);        // erases [itlow,itup)

  // print content:
  for (std::map<char,int>::iterator it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';

  return 0;
}
```

Output

```
a => 20
e => 100
```

#### map::upper_bound

å°†è¿­ä»£å™¨è¿”å›åˆ°ä¸Šé™

è¿”å›ä¸€ä¸ªæŒ‡å‘å®¹å™¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼Œå®ƒçš„å…³é”®å­—è¢«è®¤ä¸ºæ˜¯åœ¨kä¹‹åã€‚

è¯¥å‡½æ•°ä½¿ç”¨å…¶å†…éƒ¨æ¯”è¾ƒå¯¹è±¡ï¼ˆkey\_compï¼‰æ¥ç¡®å®šè¿™ä¸€ç‚¹ï¼Œå°†è¿­ä»£å™¨è¿”å›åˆ°key\_compï¼ˆkï¼Œelement\_keyï¼‰å°†è¿”å›trueçš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

å¦‚æœmapç±»ç”¨é»˜è®¤çš„æ¯”è¾ƒç±»å‹ï¼ˆlessï¼‰å®ä¾‹åŒ–ï¼Œåˆ™å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå…¶é”®å¤§äºkã€‚

ç±»ä¼¼çš„æˆå‘˜å‡½æ•°lower\_boundå…·æœ‰ä¸upper\_boundç›¸åŒçš„è¡Œä¸ºï¼Œé™¤äº†mapåŒ…å«ä¸€ä¸ªå…ƒç´ ï¼Œå…¶é”®å€¼ç­‰äºkï¼šåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œlower\_boundè¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ï¼Œè€Œupper\_boundè¿”å›æŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚

```cpp
      iterator upper_bound (const key_type& k);
const_iterator upper_bound (const key_type& k) const;
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;
  std::map<char,int>::iterator itlow,itup;

  mymap['a']=20;
  mymap['b']=40;
  mymap['c']=60;
  mymap['d']=80;
  mymap['e']=100;

  itlow=mymap.lower_bound ('b');  // itlow points to b
  itup=mymap.upper_bound ('d');   // itup points to e (not d!)

  mymap.erase(itlow,itup);        // erases [itlow,itup)

  // print content:
  for (std::map<char,int>::iterator it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';

  return 0;
}
```

Output

```
a => 20
e => 100
```

#### map::equal_range

è·å–ç›¸åŒå…ƒç´ çš„èŒƒå›´

è¿”å›åŒ…å«å®¹å™¨ä¸­æ‰€æœ‰å…·æœ‰ä¸kç­‰ä»·çš„é”®çš„å…ƒç´ çš„èŒƒå›´è¾¹ç•Œã€‚ ç”±äºåœ°å›¾å®¹å™¨ä¸­çš„å…ƒç´ å…·æœ‰å”¯ä¸€é”®ï¼Œæ‰€ä»¥è¿”å›çš„èŒƒå›´æœ€å¤šåªåŒ…å«ä¸€ä¸ªå…ƒç´ ã€‚ 

å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…ï¼Œåˆ™è¿”å›çš„èŒƒå›´å…·æœ‰é›¶çš„é•¿åº¦ï¼Œä¸ä¸¤ä¸ªè¿­ä»£å™¨æŒ‡å‘å…·æœ‰è€ƒè™‘å»åä¸€ä¸ªå¯†é’¥å¯¹æ‰€è¿°ç¬¬ä¸€å…ƒä»¶Ä·æ ¹æ®å®¹å™¨çš„å†…éƒ¨æ¯”è¾ƒå¯¹è±¡ï¼ˆkey\_compï¼‰ã€‚å¦‚æœå®¹å™¨çš„æ¯”è¾ƒå¯¹è±¡è¿”å›falseï¼Œåˆ™ä¸¤ä¸ªé”®è¢«è®¤ä¸ºæ˜¯ç­‰ä»·çš„ã€‚


```cpp
pair<const_iterator,const_iterator> equal_range (const key_type& k) const;
pair<iterator,iterator>             equal_range (const key_type& k);
```

Example

```cpp
#include <iostream>
#include <map>

int main ()
{
  std::map<char,int> mymap;

  mymap['a']=10;
  mymap['b']=20;
  mymap['c']=30;

  std::pair<std::map<char,int>::iterator,std::map<char,int>::iterator> ret;
  ret = mymap.equal_range('b');

  std::cout << "lower bound points to: ";
  std::cout << ret.first->first << " => " << ret.first->second << '\n';

  std::cout << "upper bound points to: ";
  std::cout << ret.second->first << " => " << ret.second->second << '\n';

  return 0;
}
```

Output

```
lower bound points to: 'b' => 20
upper bound points to: 'c' => 30
```

### multimap

### æ— åºå®¹å™¨ï¼ˆUnordered Containerï¼‰ï¼šunordered\_setã€unordered\_multisetã€unordered\_mapã€unordered\_multimap

åŒ…æ‹¬ï¼š

* unordered\_set
* unordered\_multiset
* unordered\_map
* unordered\_multimap

éƒ½æ˜¯ä»¥å“ˆå¸Œè¡¨å®ç°çš„ã€‚

![](assets/stlæ€»ç»“/20160410123436394)

unordered\_setã€unodered\_multisetç»“æ„ï¼š

![](assets/stlæ€»ç»“/20160410123518692)

unordered\_mapã€unodered\_multimapç»“æ„ï¼š

![](assets/stlæ€»ç»“/20160410123525739)

### unordered_set 

### unordered_multiset 

### unordered_map 

### unordered_multimap 

### tuple

å…ƒç»„æ˜¯ä¸€ä¸ªèƒ½å¤Ÿå®¹çº³å…ƒç´ é›†åˆçš„å¯¹è±¡ã€‚æ¯ä¸ªå…ƒç´ å¯ä»¥æ˜¯ä¸åŒçš„ç±»å‹ã€‚

```cpp
template <class... Types> class tuple;
```

Example

```cpp
#include <iostream>     // std::cout
#include <tuple>        // std::tuple, std::get, std::tie, std::ignore

int main ()
{
  std::tuple<int,char> foo (10,'x');
  auto bar = std::make_tuple ("test", 3.1, 14, 'y');

  std::get<2>(bar) = 100;                                    // access element

  int myint; char mychar;

  std::tie (myint, mychar) = foo;                            // unpack elements
  std::tie (std::ignore, std::ignore, myint, mychar) = bar;  // unpack (with ignore)

  mychar = std::get<3>(bar);

  std::get<0>(foo) = std::get<2>(bar);
  std::get<1>(foo) = mychar;

  std::cout << "foo contains: ";
  std::cout << std::get<0>(foo) << ' ';
  std::cout << std::get<1>(foo) << '\n';

  return 0;
}
```

Output

```
foo contains: 100 y
```

#### tuple::tuple

æ„å»ºä¸€ä¸ª tupleï¼ˆå…ƒç»„ï¼‰å¯¹è±¡ã€‚

è¿™æ¶‰åŠå•ç‹¬æ„å»ºå…¶å…ƒç´ ï¼Œåˆå§‹åŒ–å–å†³äºè°ƒç”¨çš„æ„é€ å‡½æ•°å½¢å¼ï¼š

ï¼ˆ1ï¼‰é»˜è®¤çš„æ„é€ å‡½æ•°

æ„å»ºä¸€ä¸ª å…ƒç»„å¯¹è±¡çš„å…ƒç´ å€¼åˆå§‹åŒ–ã€‚

ï¼ˆ2ï¼‰å¤åˆ¶/ç§»åŠ¨æ„é€ å‡½æ•°

è¯¥å¯¹è±¡ä½¿ç”¨tplçš„å†…å®¹è¿›è¡Œåˆå§‹åŒ– å…ƒç»„ç›®çš„ã€‚tpl
çš„ç›¸åº”å…ƒç´ è¢«ä¼ é€’ç»™æ¯ä¸ªå…ƒç´ çš„æ„é€ å‡½æ•°ã€‚

ï¼ˆ3ï¼‰éšå¼è½¬æ¢æ„é€ å‡½æ•°

åŒä¸Šã€‚tplä¸­çš„
æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥éšå«åœ°è½¬æ¢ä¸ºæ„é€ ä¸­å®ƒä»¬å„è‡ªå…ƒç´ çš„ç±»å‹å…ƒç»„ ç›®çš„ã€‚

ï¼ˆ4ï¼‰åˆå§‹åŒ–æ„é€ å‡½æ•°
ç”¨elemsä¸­çš„ç›¸åº”å…ƒç´ åˆå§‹åŒ–æ¯ä¸ªå…ƒç´ ã€‚elems
çš„ç›¸åº”å…ƒç´ è¢«ä¼ é€’ç»™æ¯ä¸ªå…ƒç´ çš„æ„é€ å‡½æ•°ã€‚

ï¼ˆ5ï¼‰å¯¹è½¬æ¢æ„é€ å‡½æ•°

è¯¥å¯¹è±¡æœ‰ä¸¤ä¸ªå¯¹åº”äºpr.firstå’Œçš„å…ƒç´ pr.secondã€‚PRä¸­çš„æ‰€æœ‰ç±»å‹éƒ½åº”è¯¥éšå«åœ°è½¬æ¢ä¸ºå…¶ä¸­å„è‡ªå…ƒç´ çš„ç±»å‹å…ƒç»„ ç›®çš„ã€‚

ï¼ˆ6ï¼‰åˆ†é…å™¨ç‰ˆæœ¬

å’Œä¸Šé¢çš„ç‰ˆæœ¬ä¸€æ ·ï¼Œé™¤äº†æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä½¿ç”¨allocator allocæ„é€ çš„ã€‚

```cpp
default (1)	
constexpr tuple();
copy / move (2)	
tuple (const tuple& tpl) = default;
tuple (tuple&& tpl) = default;
implicit conversion (3)	
template <class... UTypes>
  tuple (const tuple<UTypes...>& tpl);
template <class... UTypes>
  tuple (tuple<UTypes...>&& tpl);
initialization (4)	
explicit tuple (const Types&... elems);
template <class... UTypes>
  explicit tuple (UTypes&&... elems);
conversion from pair (5)	
template <class U1, class U2>
  tuple (const pair<U1,U2>& pr);
template <class U1, class U2>
  tuple (pair<U1,U2>&& pr);
allocator (6)	
template<class Alloc>
  tuple (allocator_arg_t aa, const Alloc& alloc);
template<class Alloc>
  tuple (allocator_arg_t aa, const Alloc& alloc, const tuple& tpl);
template<class Alloc>
  tuple (allocator_arg_t aa, const Alloc& alloc, tuple&& tpl);
template<class Alloc,class... UTypes>
  tuple (allocator_arg_t aa, const Alloc& alloc, const tuple<UTypes...>& tpl);
template<class Alloc, class... UTypes>
  tuple (allocator_arg_t aa, const Alloc& alloc, tuple<UTypes...>&& tpl);
template<class Alloc>
  tuple (allocator_arg_t aa, const Alloc& alloc, const Types&... elems);
template<class Alloc, class... UTypes>
  tuple (allocator_arg_t aa, const Alloc& alloc, UTypes&&... elems);
template<class Alloc, class U1, class U2>
  tuple (allocator_arg_t aa, const Alloc& alloc, const pair<U1,U2>& pr);
template<class Alloc, class U1, class U2>
  tuple (allocator_arg_t aa, const Alloc& alloc, pair<U1,U2>&& pr);
```

Example

```cpp
#include <iostream>     // std::cout
#include <utility>      // std::make_pair
#include <tuple>        // std::tuple, std::make_tuple, std::get

int main ()
{
  std::tuple<int,char> first;                             // default
  std::tuple<int,char> second (first);                    // copy
  std::tuple<int,char> third (std::make_tuple(20,'b'));   // move
  std::tuple<long,char> fourth (third);                   // implicit conversion
  std::tuple<int,char> fifth (10,'a');                    // initialization
  std::tuple<int,char> sixth (std::make_pair(30,'c'));    // from pair / move

  std::cout << "sixth contains: " << std::get<0>(sixth);
  std::cout << " and " << std::get<1>(sixth) << '\n';

  return 0;
}
```

Output

```
sixth contains: 30 and c
```

### pair

è¿™ä¸ªç±»æŠŠä¸€å¯¹å€¼ï¼ˆvaluesï¼‰ç»“åˆåœ¨ä¸€èµ·ï¼Œè¿™äº›å€¼å¯èƒ½æ˜¯ä¸åŒçš„ç±»å‹ï¼ˆT1 å’Œ T2ï¼‰ã€‚æ¯ä¸ªå€¼å¯ä»¥è¢«å…¬æœ‰çš„æˆå‘˜å˜é‡firstã€secondè®¿é—®ã€‚

pairæ˜¯tupleï¼ˆå…ƒç»„ï¼‰çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚

pairçš„å®ç°æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œä¸»è¦çš„ä¸¤ä¸ªæˆå‘˜å˜é‡æ˜¯first second å› ä¸ºæ˜¯ä½¿ç”¨structä¸æ˜¯classï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ä½¿ç”¨pairçš„æˆå‘˜å˜é‡ã€‚

åº”ç”¨ï¼š

* å¯ä»¥å°†ä¸¤ä¸ªç±»å‹æ•°æ®ç»„åˆæˆä¸€ä¸ªå¦‚map<key, value>
* å½“æŸä¸ªå‡½æ•°éœ€è¦ä¸¤ä¸ªè¿”å›å€¼æ—¶

```cpp
template <class T1, class T2> struct pair;
```

#### pair::pair

æ„å»ºä¸€ä¸ªpairå¯¹è±¡ã€‚

è¿™æ¶‰åŠåˆ°å•ç‹¬æ„å»ºå®ƒçš„ä¸¤ä¸ªç»„ä»¶å¯¹è±¡ï¼Œåˆå§‹åŒ–ä¾èµ–äºè°ƒç”¨çš„æ„é€ å™¨å½¢å¼ï¼š

ï¼ˆ1ï¼‰é»˜è®¤çš„æ„é€ å‡½æ•°

æ„å»ºä¸€ä¸ª å¯¹å¯¹è±¡çš„å…ƒç´ å€¼åˆå§‹åŒ–ã€‚

ï¼ˆ2ï¼‰å¤åˆ¶/ç§»åŠ¨æ„é€ å‡½æ•°ï¼ˆå’Œéšå¼è½¬æ¢ï¼‰

è¯¥å¯¹è±¡è¢«åˆå§‹åŒ–ä¸ºprçš„å†…å®¹ å¯¹ç›®çš„ã€‚pr
çš„ç›¸åº”æˆå‘˜è¢«ä¼ é€’ç»™æ¯ä¸ªæˆå‘˜çš„æ„é€ å‡½æ•°ã€‚

ï¼ˆ3ï¼‰åˆå§‹åŒ–æ„é€ å‡½æ•°

ä¼šå‘˜ ç¬¬ä¸€æ˜¯ç”±ä¸€ä¸ªå’Œæˆå‘˜æ„å»ºçš„ç¬¬äºŒä¸bã€‚

ï¼ˆ4ï¼‰åˆ†æ®µæ„é€ 

æ„é€ æˆå‘˜ first  å’Œ second  åˆ°ä½ï¼Œä¼ é€’å…ƒç´ first\_args ä½œä¸ºå‚æ•°çš„æ„é€ å‡½æ•° firstï¼Œå’Œå…ƒç´  second\_args åˆ°çš„æ„é€ å‡½æ•° second ã€‚

```cpp
default (1)	
constexpr pair();
copy / move (2)	
template<class U, class V> pair (const pair<U,V>& pr);
template<class U, class V> pair (pair<U,V>&& pr);
pair (const pair& pr) = default;
pair (pair&& pr) = default;
initialization (3)	
pair (const first_type& a, const second_type& b);
template<class U, class V> pair (U&& a, V&& b);
piecewise (4)	
template <class... Args1, class... Args2>
  pair (piecewise_construct_t pwc, tuple<Args1...> first_args,
                                   tuple<Args2...> second_args);
```

Example

```cpp
#include <utility>      // std::pair, std::make_pair
#include <string>       // std::string
#include <iostream>     // std::cout

int main () {
  std::pair <std::string,double> product1;                     // default constructor
  std::pair <std::string,double> product2 ("tomatoes",2.30);   // value init
  std::pair <std::string,double> product3 (product2);          // copy constructor

  product1 = std::make_pair(std::string("lightbulbs"),0.99);   // using make_pair (move)

  product2.first = "shoes";                  // the type of first is string
  product2.second = 39.90;                   // the type of second is double

  std::cout << "The price of " << product1.first << " is $" << product1.second << '\n';
  std::cout << "The price of " << product2.first << " is $" << product2.second << '\n';
  std::cout << "The price of " << product3.first << " is $" << product3.second << '\n';
  return 0;
}
```

Output

```
The price of lightbulbs is $0.99
The price of shoes is $39.9
The price of tomatoes is $2.3
```